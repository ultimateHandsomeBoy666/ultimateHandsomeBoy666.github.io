<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ultimateHandsomeBoy666.github.io/</id>
    <title>牛蛙的博客</title>
    <updated>2021-03-14T12:13:32.969Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ultimateHandsomeBoy666.github.io/"/>
    <link rel="self" href="https://ultimateHandsomeBoy666.github.io/atom.xml"/>
    <subtitle>Hello!</subtitle>
    <logo>https://ultimateHandsomeBoy666.github.io/images/avatar.png</logo>
    <icon>https://ultimateHandsomeBoy666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 牛蛙的博客</rights>
    <entry>
        <title type="html"><![CDATA[Android 实现图表实时更新]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/android-shi-xian-tu-biao-shi-shi-geng-xin/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/android-shi-xian-tu-biao-shi-shi-geng-xin/">
        </link>
        <updated>2019-05-22T11:05:57.000Z</updated>
        <content type="html"><![CDATA[<p>项目里需要App端不断地从服务器获取数据，实时生成图表。图表控件使用的是<a href="https://github.com/PhilJay/MPAndroidChart">MPAndroidChart</a>。自己写了些实时更新折线图的demo，数据是线程随机生成的，不是后台数据。</p>
<h3 id="1-message配合handler实现">1、Message配合Handler实现</h3>
<p>效果如下<br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615723745197.gif" alt="Message配合Handler实现.gif" loading="lazy"><br>
在MainActivity中创建一个产生随机数据的线程，每产生一个数据发送一个Message，Handler收到Message之后更新折线图。</p>
<p>MainActivity代码如下：</p>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {
    private static final int TAG = 1;//Message的what标识
    private TextView mTextView;
    private Button mStartButton;

    private LineChart mLineChart;
    private Data[] mDatas;
    private List&lt;Entry&gt; mEntries = new ArrayList&lt;&gt;();

    private Thread mThread;
    private Handler mHandler;
    private Random mRandom;

    private StringBuilder mStringBuilder;
    private int mEndIndex;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mTextView = findViewById(R.id.test_txt);
        mStartButton = findViewById(R.id.start_button);
        mLineChart = findViewById(R.id.line_chart);

        mRandom = new Random();
        mStringBuilder = new StringBuilder(&quot;现在Y轴数字是0哦&quot;);
        mEndIndex = 1;

        //先创建5个Data数据
        mDatas = new Data[]{new Data(1,5),new Data(2,8),
               new Data(3,10),new Data(4,13),new Data(5,16)};
        for (Data data :mDatas){
            mEntries.add(new Entry(data.getValueX(),data.getValueY()));
        }
        LineDataSet dataSet = new LineDataSet(mEntries,&quot;number&quot;);
        LineData lineData = new LineData(dataSet);
        mLineChart.setData(lineData);
        mLineChart.invalidate();


        mHandler = new Handler(){
            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                if (msg.what==TAG){
                    updateTxt(msg);
                    updateChart(msg);
                }
            }
        };

        mThread = new Thread(new Runnable() {
            @Override
            public void run() {
                int corrX = 6;//已经有了五个数据，下一个数据的x坐标从6开始
                while (true){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    int corrY = mRandom.nextInt(20) + 5;
                    Message message = Message.obtain();
                    message.arg1 = corrY;
                    message.arg2 = corrX;
                    message.what = TAG;
                    mHandler.sendMessage(message);
                    corrX += 1;
                }
            }
        });

        mStartButton.setOnClickListener((View v) -&gt; mThread.start());

    }

    //更新SpannableString类型的文本需要用该函数判断更新数字的位数
    private int endIndex(int i){
        int index = 0;
        while (i!=0){
            i = i/10;
            index += 1;
        }
        return index;
    }

    //更新显示当前值的TextView
    private void updateTxt(Message msg){
        mStringBuilder.replace(7,7 + mEndIndex, msg.arg1 + &quot;&quot;);//将原来的数字替换

        SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder(mStringBuilder);
        ForegroundColorSpan foregroundColorSpan = new ForegroundColorSpan(Color.BLUE);
        RelativeSizeSpan relativeSizeSpan = new RelativeSizeSpan(1.5f);

        mEndIndex = endIndex(msg.arg1);//新的y值的位数

        spannableStringBuilder.setSpan(foregroundColorSpan,7,7 + mEndIndex, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
        spannableStringBuilder.setSpan(relativeSizeSpan,7,7 + mEndIndex, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
        mTextView.setText(spannableStringBuilder);

    }

    //刷新折线图
    private void updateChart(Message msg){
        mEntries.add(new Entry(msg.arg2,msg.arg1));
        LineDataSet dataSet = new LineDataSet(mEntries,&quot;number&quot;);
        LineData lineData = new LineData(dataSet);
        mLineChart.setData(lineData);
        mLineChart.invalidate();
    }

}
</code></pre>
<p>Data类如下</p>
<pre><code class="language-Java">public class Data {
    private int valueX;
    private int valueY;

    public Data(int x,int y){
        this.valueX = x;
        this.valueY = y;
    }

    public int getValueX() {
        return valueX;
    }

    public void setValueX(int valueX) {
        this.valueX = valueX;
    }

    public int getValueY() {
        return valueY;
    }

    public void setValueY(int valueY) {
        this.valueY = valueY;
    }
}
</code></pre>
<h3 id="2-rxjava实现">2、RxJava实现</h3>
<p>Rxjava在处理复杂的多线程事件逻辑时比Handler/Async等要简单易用可靠。用来写这个demo算是大炮打蚊子，纯当练手了。</p>
<p>MainActivity</p>
<pre><code class="language-Java">public class MainActivity extends AppCompatActivity {
    private static final String TAG = &quot;MainActivity&quot;;
    private LineChart mLineChart;
    private TextView mTextView;
    private Button mStartButton;
    private List&lt;Entry&gt; mEntryList = new ArrayList&lt;&gt;();

    private Random mRandom;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mLineChart = findViewById(R.id.line_chart);
        mStartButton = findViewById(R.id.start_button);
        mTextView = findViewById(R.id.value_txt);

        mStartButton.setOnClickListener((View v) -&gt; intervalObservable());
    }

    private void intervalObservable() {
        mRandom = new Random();
        Observable.interval(1000, 1000, TimeUnit.MILLISECONDS)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;Long&gt;() {
                    @Override
                    public void accept(Long aLong) throws Exception {
                        Log.e(&quot;intervalObservable&quot;, Thread.currentThread().getName());
                        Long x = aLong;
                        int y = mRandom.nextInt(10);
                        Data data = new Data(x, y);
                        x++;

                        mEntryList.add(new Entry(data.getX(), data.getY()));
                        LineDataSet dataSet = new LineDataSet(mEntryList, &quot;label&quot;);
                        LineData lineData = new LineData(dataSet);
                        mLineChart.setData(lineData);
                        mLineChart.invalidate();
                        mTextView.setText(&quot;当前y值为&quot; + y);
                    }
                });
    }
}
</code></pre>
<p>写的时候发现如果直接用Observable.create()生成数据的话，速度太快，MPAndroidChart刷新不过来，一片空白。所以改用Observable.interval()，每个1秒生成一个，但是这个函数只能返回一个Observable<Long>的对象，每次发射的都是Long类型的数据，所以把Data类型中的x值改成了Long类型。<br>
还要注意的是，Observable.interval()默认订阅Schedulers.computation这个线程，如果有UI更新的话，需要在主线程中进行观察，即调用observeOn(AndroidSchedulers.mainThread())。<br>
<strong>但是我发现一个很神奇的事，MPAndroidChart可以在非UI线程中进行刷新</strong>。</p>
<p>难道只能用Observal.interval()吗?其实不是的，我发现只要使被观察者线程休眠一小段时间，就能让折线图刷新出来，代码如下</p>
<pre><code class="language-java">Observable.create(new ObservableOnSubscribe&lt;Data&gt;() {
            @Override
            public void subscribe(@NonNull ObservableEmitter&lt;Data&gt; e) throws Exception {
                Long x = 0l;
                Random random = new Random();
                while(x &lt; 1000) {
                    int y = random.nextInt(10);
                    Data data = new Data(x, y);
                    e.onNext(data);
                    x++;
                    Thread.sleep(1000);//休眠1秒
                }
                Log.e(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());
            }
        }).subscribeOn(Schedulers.newThread())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(data -&gt; {
                Log.i(&quot;onNext(Data data)&quot;, data.toString());
                Log.e(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());
                mEntryList.add(new Entry(data.getX(), data.getY()));
                LineDataSet dataSet = new LineDataSet(mEntryList, &quot;label&quot;);
                LineData lineData = new LineData(dataSet);
                mLineChart.setData(lineData);
                mLineChart.invalidate();
                mTextView.setText(&quot;当前值为&quot; + data.getY());
            });
</code></pre>
<p>其实在订阅者线程中休眠也可以正常接收到数据，但订阅者线程一般是UI线程，休眠的话，UI就不会更新了。<br>
另外，被观察者的线程没有休眠的话，即使被观察者数据发送的很快，订阅者在onNext()即使进行了线程休眠，数据也能全部接收到，不会出现事件丢失的情况，这一点让我比较疑惑。<br>
如果被观察者的线程调用了Thread.sleep(1)，而观察者在onNext()中调用了Thread.sleep(1000)，那么会出现上下游事件处理速率不匹配，事件丢失，OOM等情况。<br>
这个时候就要用支持背压的Flowable了。<br>
其实用Flowable同样可以实现折线图更新，代码如下：</p>
<pre><code class="language-java">Flowable.create(new FlowableOnSubscribe&lt;Data&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Data&gt; e) throws Exception{
                Long x = 0l;
                Random random = new Random();
                while(x &lt; 1000) {
                    int y = random.nextInt(10);
                    Data data = new Data(x, y);
                    e.onNext(data);
                    x++;
                    Thread.sleep(1000);
                }
                Log.e(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());
            }
        }, BackpressureStrategy.BUFFER).subscribeOn(Schedulers.newThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Subscriber&lt;Data&gt;() {
                    Subscription mSubscription;
                    @Override
                    public void onSubscribe(Subscription s) {
                        mSubscription = s;
                        s.request(1);
                    }

                    @Override
                    public void onNext(Data data) {
                        Log.i(&quot;onNext(Data data)&quot;, data.toString());
                        Log.e(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());
                        mEntryList.add(new Entry(data.getX(), data.getY()));
                        LineDataSet dataSet = new LineDataSet(mEntryList, &quot;label&quot;);
                        LineData lineData = new LineData(dataSet);
                        mLineChart.setData(lineData);
                        mLineChart.invalidate();
                        mTextView.setText(&quot;当前值为&quot; + data.getY());

                        mSubscription.request(1);
                    }

                    @Override
                    public void onError(Throwable t) {

                    }

                    @Override
                    public void onComplete() {

                    }
                });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 退出登录，清空任务栈]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/android-tui-chu-deng-lu-qing-kong-ren-wu-zhan/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/android-tui-chu-deng-lu-qing-kong-ren-wu-zhan/">
        </link>
        <updated>2019-05-15T11:47:24.000Z</updated>
        <content type="html"><![CDATA[<p>在项目中要实现用户退出登录的功能，当用户点击退出登录按钮后，跳转到登录页面的 Activity ，直接用 startActivity() 跳转，点击返回键后仍会回到退出前的 Activity 。</p>
<p>如果使用下面这句代码给 intent 设置 Flag</p>
<pre><code class="language-java">intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
</code></pre>
<p>在第一次登录时有效，因为用户第一次登录时会在登录页面输入账号密码进行登录，然后跳转到主页面。这样在退出登录时，会回到之前经过的登录 Activity ，任务栈会将登录页面<br>
Activity 之上的 Activity 全部清空，按返回键不会回到主页面。<br>
但是在用户已经登录过之后，由于账号密码已经保存，不需要再次输入进行登录，不会经过登录 Activity ， 这样在退出登录后按返回键仍会返回到主页面。</p>
<p>使用 FLAG_ACTIVITY_CLEAR_TASK ， FLAG_ACTIVITY_NEW_TASK 即可解决。代码如下：</p>
<pre><code class="language-java">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
</code></pre>
<p><strong>注意是 addFlags() 不是 setFlags()</strong><br>
谷歌官方文档提到， Intent.FLAG_ACTIVITY_CLEAR_TASK 要起作用，必须和 Intent.FLAG_ACTIVITY_NEW_TASK 配合使用。<br>
这两个 Flag 可以将原有任务栈清空,并将 intent 的目标 Activity 作为任务栈的根 Activity 。任务栈的 Id 没有变，如下所示，也就是说，并没有开辟新的任务栈。</p>
<pre><code>I/得到TaskId: 19959
</code></pre>
<pre><code>I/得到TaskId: 19959
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HashMap 和 HashTable 的区别]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/hashmap-he-hashtable-de-qu-bie/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/hashmap-he-hashtable-de-qu-bie/">
        </link>
        <updated>2019-04-29T10:57:03.000Z</updated>
        <content type="html"><![CDATA[<p>1、HashTable和HashMap均实现了Map、Cloneable、Serializable接口，但是HashMap继承至实现了Map接口的AbstractMap类，而HashTable除了实现Map接口，还继承了已被废弃的Dicationary类，如下图所示：<br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615719886086.png" alt="HashMap 的继承关系" loading="lazy"><br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615719976617.png" alt="HashTable 的继承关系" loading="lazy"><br>
2、HashMap的key和value值可以为null，而HashTable遇到null会抛出NullPointerException。HashMap遇到null的key会将其赋值为0。<br>
3、HashTable是线程安全的，而HashMap不是。如果你需要线程安全的HashMap，使用ConcurrentHashMap。或者用如下代码让HashMap同步：</p>
<pre><code class="language-java">Map map = Collections.synchronizeMap(hashMap);
</code></pre>
<p>如果不需要线程安全，使用HashMap，HashTable已经不再推荐使用。<br>
4、HashMap的迭代器(Iterator)是fail-fast(快速失败)迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p>
<p>感谢参考文章：<br>
1、<a href="http://www.importnew.com/7010.html">HashMap和Hashtable的区别</a><br>
2、 <a href="https://www.cnblogs.com/xinzhao/p/5644175.html">HashMap和HashTable到底哪不同？</a></p>
]]></content>
    </entry>
</feed>