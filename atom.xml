<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ultimateHandsomeBoy666.github.io/</id>
    <title>牛蛙的博客</title>
    <updated>2021-03-14T19:34:53.455Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ultimateHandsomeBoy666.github.io/"/>
    <link rel="self" href="https://ultimateHandsomeBoy666.github.io/atom.xml"/>
    <subtitle>Hello!</subtitle>
    <logo>https://ultimateHandsomeBoy666.github.io/images/avatar.png</logo>
    <icon>https://ultimateHandsomeBoy666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 牛蛙的博客</rights>
    <entry>
        <title type="html"><![CDATA[Android 嵌套滑动总结]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/android-qian-tao-hua-dong-zong-jie/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/android-qian-tao-hua-dong-zong-jie/">
        </link>
        <updated>2021-03-14T10:25:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-什么是嵌套滑动">一、什么是嵌套滑动</h3>
<p>嵌套滑动是 android 开发中常见的一种 UI 效果。当一个布局中包含多个可以滑动的 View，并且这些 View 互相嵌套的时候，就需要做嵌套滑动的处理来让 UI 交互有更流畅的效果，比如吸顶效果。常见的效果如下：</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbee9045194e4b09a0fd92554693c80c~tplv-k3u1fbpfcp-watermark.image" alt="1615737449263149" height="240px" width="160px"/>
<p>如上所示，最外层的父布局可以滑动，内层的 RecyclerView 也可以滑动。当上滑 RecyclerView 的时候，最外层的父布局先上滑，直到上滑到 tab 的时候，这时候 RecyclerView 开始滑动，父布局停止滑动，并且手指不需要离开屏幕，可以一次性完成整个操作。这样就达到了内外布局连贯滑动的效果，并且达到了 tab 吸顶的效果。</p>
<h3 id="二-滑动嵌套解决方案">二、滑动嵌套解决方案</h3>
<p>那么如何才能做到这样的连贯的嵌套滑动呢？</p>
<h4 id="1-手动覆写事件分发与拦截">1、手动覆写事件分发与拦截</h4>
<p>大家都很熟悉 android 的事件分发机制，要做到嵌套滑动的效果，重写事件分发是最为原始的一种方法，早期的 android 开发们就是这样做的。以之前展示的效果的为例，在 ACTION_MOVE 事件分发时，先判断 tab 位置是否到顶端，如果没到，则让外层父布局拦截掉 MOVE 事件，父布局滑动。如果已经到了，则不拦截，将事件传给子 RecyclerView，流程如下：</p>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ceab0391ad84aefa0fb815650c899d0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></figure>
<p>是否拦截事件，即重写 <code>onIntercetTouchEvent</code> 方法，是该流程的核心。</p>
<h5 id="手动重写事件分发的缺点">手动重写事件分发的缺点</h5>
<ul>
<li>
<p><strong>只适合比较简单的嵌套滑动情况</strong></p>
<p>这一点很好理解。因为你需要自己手动编写拦截逻辑，嵌套滑动的布局一旦复杂，那么就需要大量的代码和逻辑来实现嵌套滑动，增大维护的成本。所以不适合复杂的嵌套滑动布局，实际上也很难实现复杂的嵌套滑动。</p>
</li>
<li>
<p><strong>难以支持 fling</strong></p>
<p>fling 指的是滑动松手后，视图继续依靠惯性滑动的过程。一般来说，考虑到用户体验，嵌套滑动是需要支持 fling 的。那么对于手动编写事件分发来说，除了需要重写 <code>onInterceptTouchEvent</code> 之外，还需要针对 <code>ACTION_UP</code> 事件进行特定的处理，因为 fling 源于 <code>ACTION_UP</code> 事件时产生的 <code>Velocity</code>。然而事件分发机制并没有提供像 <code>onInterceptTouchEvent</code> 的那样的对外暴露的接口让开发者来处理 <code>ACITON_UP</code> 事件。只能通过复写 <code>onTouchEvent</code> 等方法来处理，而这样做的限制太大，因为你需要调用 <code>super.onTouchEvent</code>，但是你又不能修改其中的代码。</p>
</li>
<li>
<p><strong>没有办法实现连贯的吸顶嵌套滑动</strong></p>
<p>还是以之前的例子来说，当 tab 吸顶后，我们希望的是手指不松开继续往上滑可以使 RecyclerView 往上滑，然而手动拦截事件的做法是做不到的，必须先抬起手指然后再次滑动。为什么会这样？看看  <code>dispatchTouchEvent</code>  中的代码：</p>
<pre><code class="language-java">if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
                ......
            } else {
  // 当 MotionEvent 为 ACTION_MOVE 且 mFirstTouchTarget == null 时，仍然拦截事件
                intercepted = true;
            }
</code></pre>
<p>当 ViewGroup 在分发事件时，如果 <code>mFirstTouchTarget == null</code> 则说明 ViewGroup 中没有子 View 来消费事件，该事件由 ViewGroup 自己处理。而当 ViewGroup 拦截事件后，恰恰会将 <code>mFirstTouchTarget</code> 置空。回到之前的例子，当外层滑动父布局拦截了 <code>ACTION_MOVE</code> 事件后，会将 <code>mFirstTouchTarget</code> 置空。接下来即使吸顶后不拦截事件，由于 <code>mFirstTouchTarget</code> 已经为 <code>null</code>，所以事件不会传递到子 RecyclerView，而是继续由父布局消费。这样就没有达到连贯的吸顶嵌套滑动的效果。</p>
</li>
</ul>
<h4 id="2-coordinatorlayout-appbar-behavior-scrollflag">2、CoordinatorLayout + AppBar + Behavior + scrollFlag</h4>
<p><code>CoordinatorLayout</code> 是 google 提供的一套可以实现复杂交互效果的布局，和 <code>AppBar</code> 、<code>Behavior</code>、<code>scrollFlag</code> 配合使用，可以解耦地定制多种效果，这些效果由 <code>Behavior</code> 和 <code>scrollFlag</code>指定。并且 <code>Behavior</code> 可以自定义。</p>
<p>要用 <code>CoordinatorLayout</code> 实现嵌套滑动非常简单，只要按如下编写布局文件：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.coordinatorlayout.widget.CoordinatorLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;com.google.android.material.appbar.AppBarLayout
        android:layout_height=&quot;300dp&quot;
        android:layout_width=&quot;match_parent&quot;&gt;
        
      	// 可滑动部分
        &lt;View
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;0dp&quot;
            android:layout_weight=&quot;1&quot;
            app:layout_scrollFlags=&quot;scroll&quot;/&gt;

        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;64dp&quot;
            android:layout_gravity=&quot;bottom&quot;
            android:text=&quot;Top&quot;
            android:textSize=&quot;32sp&quot;
            android:textColor=&quot;@color/white&quot;
            android:gravity=&quot;center&quot;
            android:textStyle=&quot;bold&quot;/&gt;

    &lt;/com.google.android.material.appbar.AppBarLayout&gt;

    &lt;androidx.recyclerview.widget.RecyclerView
        android:id=&quot;@+id/rv&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt;

&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;
</code></pre>
<p>将 <code>AppBarLayout</code> 中需要上滑隐藏的部分的 <code>scrollFlag</code>指定为 <code>scroll</code> ，在RecyclerView 中指定 <code>behavior</code> 为 <code>appbar_scrolling_view_behavior</code> 就可以实现最简单的吸顶嵌套滑动，如下：</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb76cc0af0dd48769b24d6c2f8ec3342~tplv-k3u1fbpfcp-watermark.image" alt="1615743833115315" height="240px" width="160px" />
<p>看起来像带有 header 的 RecyclerView 在滑动，但其实是嵌套滑动。</p>
<p><code>layout_scrollFlags</code> 和 <code>layout_behavior</code> 有很多可选值，配合起来可以实现多种效果，不只限于嵌套滑动。具体可以参考 API 文档。</p>
<p>使用 <code>CoordinatorLayout</code> 实现嵌套滑动比手动实现要好得多，既可以实现连贯的吸顶嵌套滑动，又支持 fling。而且是官方提供的布局，可以放心使用，出 bug 的几率很小，性能也不会有问题。不过也正是因为官方将其封装得很好，使用 <code>CoordinatorLayout</code> 很难实现比较复杂的嵌套滑动布局，比如多级嵌套滑动。</p>
<h4 id="3-嵌套滑动组件-nestedscrollingparent-和-nestedscrollingchild">3、嵌套滑动组件 NestedScrollingParent 和 NestedScrollingChild</h4>
<p><code>NestedScrollingParent</code> 和 <code>NestedScrollingChild</code> 是 google 官方提供地一套专门用来解决嵌套滑动地组件。它们是两个接口，代码如下：</p>
<pre><code class="language-java">public interface NestedScrollingParent2 extends NestedScrollingParent {

    boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes,
            @NestedScrollType int type);

    void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes,
            @NestedScrollType int type);

    void onStopNestedScroll(@NonNull View target, @NestedScrollType int type);

    void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed,
            int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type);

    void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed,
            @NestedScrollType int type);

}

public interface NestedScrollingChild2 extends NestedScrollingChild {
    
    boolean startNestedScroll(@ScrollAxis int axes, @NestedScrollType int type);

    void stopNestedScroll(@NestedScrollType int type);

    boolean hasNestedScrollingParent(@NestedScrollType int type);

    boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,
            int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow,
            @NestedScrollType int type);

    boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed,
            @Nullable int[] offsetInWindow, @NestedScrollType int type);
}

</code></pre>
<p>需要嵌套滑动的 View 可以实现这两个接口，复写其中的方法。这套组件实现嵌套滑动的核心原理很简单，主要是以下三步：</p>
<ul>
<li><code>NestedScrollingChild</code> 在 <code>onTouchEvent</code> 方法中先将 <code>ACITON_MOVE</code> 事件产生的位移 dx 和 dy 通过 <code>dispatchNestedPreScroll</code> 传递给 <code>NestedScrollingParent</code></li>
<li><code>NestedScrollingParent</code> 在 <code>onNestedPreScroll</code> 中接受到 dx 和 dy 并进行消费。并将消费掉的位移放入 <code>int[] consumed</code> 中，<code>consumed</code> 数组是一个长度为 2 的 int 类型数组，<code>consumed[0]</code> 代表 x 轴的消耗，<code>consumed[1]</code> 代表 y 轴的消耗</li>
<li><code>NestedScrollingChild</code> 之后从 <code>int[] consumed</code> 数组中拿到 <code>NestedScrollingParent</code> 已经消费掉的位移，减去之后得到剩余的位移，再由自己消费</li>
</ul>
<p>滑动位移传递方向由 child -&gt; parent -&gt; child，如下图。如果 child 是 Recyclerview ，它会先把位移给父布局消费，这时父布局滑动。当父布局滑动顶到不能滑动时，Recyclerview 这时会消费全部位移，这时它自己开始滑动，这样就形成了嵌套滑动，效果正如之前的例子中所看到的。</p>
<figure data-type="image" tabindex="2"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4df609e97e3d4cb99e2f739cc4340b00~tplv-k3u1fbpfcp-watermark.image" alt="位移传递流程" loading="lazy"></figure>
<p><code>dispatchNestedScroll</code> 和 <code>onNestedScroll</code> 的作用原理上述  preScroll 的方法类似，只不过这两个方法构造的嵌套滑动顺序和 preScroll 的相反，是子 View 先消费，子 View 消费不了的时候，再由父 View 再消费。</p>
<p>这套机制还支持 fling，在手指离开 view 的时候，即产生 <code>ACITON_UP</code> 事件时，child 将此时的 <code>Velocity</code> 转化为位移 <code>dx</code> 或 <code>dy</code>，并重复之前的流程。通过 <code>@NestedScrollType int type</code> 的值来判断是 <code>TYPE_TOUCH</code> 还是 <code>TYPE_NON_TOUCH</code>， <code>TYPE_TOUCH</code>  就是滑动， <code>TYPE_NON_TOUCH</code> 就是 fling。</p>
<h5 id="android-中哪些-view-使用了这套滑动机制">Android 中哪些 View 使用了这套滑动机制？</h5>
<ul>
<li>实现 <code>NestedScrollingParent</code> 接口的 View 有：<code>NestedScrollView</code>、<code>CoordinatorLayout</code>、<code>MotionLayout</code> 等</li>
<li>实现 <code>NestedScrollingChild</code> 接口的 View 有：<code>NestedScrollView</code>、<code>RecyclerView</code> 等</li>
<li><code>NestedScrollView</code> 是唯一同时实现两个接口的 View，这意味着它可以用作中介来实现多级嵌套滑动，后面会说到。</li>
</ul>
<p>从上面可以看到，实际上，之前提到的 <code>CoordinatorLayout</code> 实现的嵌套滑动，本质上也是通过这套 NestedScrolling 接口来实现的。但是由于它封装得太好，我们没办法做过多定制。而直接使用这套接口，就可以根据自己的需求做定制。</p>
<p>大部分的场景中，我们不需要去实现 <code>NestedScrollingChild</code> 接口，因为 RecyclerView 已经做了这个实现，而涉及到嵌套滑动场景的子 View 基本也都是 RecyclerView。我们看看 RecyclerView 的相关源码：</p>
<pre><code class="language-java">public boolean onTouchEvent(MotionEvent e) {
    ...
    case MotionEvent.ACTION_MOVE: {
               ...
                // 计算 dx，dy
                int dx = mLastTouchX - x;
                int dy = mLastTouchY - y;
				...
                    mReusableIntPair[0] = 0;
                    mReusableIntPair[1] = 0;
       				...
                    // 分发 preScroll
                    if (dispatchNestedPreScroll(
                        canScrollHorizontally ? dx : 0,
                        canScrollVertically ? dy : 0,
                        mReusableIntPair, mScrollOffset, TYPE_TOUCH
                    )) {
                        // 减去父 view 消费掉的位移
                        dx -= mReusableIntPair[0];
                        dy -= mReusableIntPair[1];
            
                        mNestedOffsets[0] += mScrollOffset[0];
                        mNestedOffsets[1] += mScrollOffset[1];
                        
                        getParent().requestDisallowInterceptTouchEvent(true);
                    }
        ...
            } break;
    ...
}


boolean scrollByInternal(int x, int y, MotionEvent ev) {
        int unconsumedX = 0;
        int unconsumedY = 0;
        int consumedX = 0;
        int consumedY = 0;
        if (mAdapter != null) {
            mReusableIntPair[0] = 0;
            mReusableIntPair[1] = 0;
            // 先消耗掉自己的 scroll
            scrollStep(x, y, mReusableIntPair);
            consumedX = mReusableIntPair[0];
            consumedY = mReusableIntPair[1];
            // 计算剩余的量
            unconsumedX = x - consumedX;
            unconsumedY = y - consumedY;
        }

        mReusableIntPair[0] = 0;
        mReusableIntPair[1] = 0;
    	// 分发 nestedScroll 给父 View，顺序和 preScroll 刚好相反
        dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset,
                TYPE_TOUCH, mReusableIntPair);
        unconsumedX -= mReusableIntPair[0];
        unconsumedY -= mReusableIntPair[1];
		...
    }
</code></pre>
<p>RecyclerView 是怎么调到父 View 的 <code>onNestedPreSroll</code> 和 <code>onNestedScroll</code> 的呢？分析一下 <code>dispatchNestedPreScroll</code> 的代码，如下，<code>dispatchNestedScroll</code> 的代码原理和此类似，不再贴出：</p>
<pre><code class="language-java">public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow,
            int type) {
        return getScrollingChildHelper().dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow,type);
    }

// NestedScrollingChildHelper.java
public boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed,
            @Nullable int[] offsetInWindow, @NestedScrollType int type) {
        if (isNestedScrollingEnabled()) {
            final ViewParent parent = getNestedScrollingParentForType(type);
            if (parent == null) {
                return false;
            }

            if (dx != 0 || dy != 0) {
                ...
                consumed[0] = 0;
                consumed[1] = 0;
                ViewParentCompat.onNestedPreScroll(parent, mView, dx, dy, consumed, type);
								...
            } 
            ...
        }
        return false;
    }

// ViewCompat.java
public static void onNestedPreScroll(ViewParent parent, View target, int dx, int dy,
            int[] consumed, int type) {
        if (parent instanceof NestedScrollingParent2) {
            // First try the NestedScrollingParent2 API
            ((NestedScrollingParent2) parent).onNestedPreScroll(target, dx, dy, consumed, type);
        } else if (type == ViewCompat.TYPE_TOUCH) {
            // Else if the type is the default (touch), try the NestedScrollingParent API
            if (Build.VERSION.SDK_INT &gt;= 21) {
                try {
                    parent.onNestedPreScroll(target, dx, dy, consumed);
                } catch (AbstractMethodError e) {
                    Log.e(TAG, &quot;ViewParent &quot; + parent + &quot; does not implement interface &quot;
                            + &quot;method onNestedPreScroll&quot;, e);
                }
            } else if (parent instanceof NestedScrollingParent) {
                ((NestedScrollingParent) parent).onNestedPreScroll(target, dx, dy, consumed);
            }
        }
    }
</code></pre>
<p>可以看到，RecyclerView 通过一个代理类 <code>NestedScrollingChildHelper</code> 完成滑动分发，最后交给 <code>ViewCompat</code> 的静态方法来让父 View 处理 <code>onNestedPreScroll</code>。<code>ViewCompat</code> 的主要作用是用来兼容不同版本的滑动接口。</p>
<h5 id="实现-onnestedprescroll-方法">实现 onNestedPreScroll 方法</h5>
<p>从上面的代码可以清楚地看到 RecyclerView 对于 <code>NestedScrollingChild</code> 的实现，以及触发嵌套滑动的时机。如果我们要实现嵌套滑动，并且内部的滑动子 View 是 RecyclerView，那么只需要让外层的父 View 实现 <code>NestedScrollingParent</code> 的方法就行了，比如在 <code>onNestedPreScroll</code> 方法中，</p>
<pre><code class="language-java"> @Override
    public void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed, int type) {
     	// 滑动 dy 距离
       scrollBy(0, dy);
        // 将消耗掉的 dy 放入 consumed 数组通知子 view
       consumed[1] = dy;
    }
</code></pre>
<p>这样就实现了最简单的嵌套滑动。当然，实际情况中，还要对滑动距离进行判断，不能让父 View 一直消费子 View 的位移。</p>
<h5 id="关于-nestedscrollview">关于 NestedScrollView</h5>
<p>像 <code>NestedScrollView</code> 这样的类，由于它内部实现了 <code>onNestedScroll</code>，所以在下滑时，它能在内部的 RecyclerView 下滑直到列表顶端时，外层继续下滑而不用抬起手指。另外也实现了 <code>onNestedPreScroll</code>方法，只不过它在该方法中把滑动继续向上传递，自己没有消费，如下代码：</p>
<pre><code class="language-java">// NestedScrollView.java
public void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed,
            int type) {
    // 只分发了 preScroll 自己并没有消费。之所以能分发是因为 NestedScrollView 同时实现了 NestedScrollingChild 接口
        dispatchNestedPreScroll(dx, dy, consumed, null, type);
    }

@Override
    public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow,
            int type) {
        return mChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type);
    }

// NestedScrollingChildHelper.java
public boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed,
            @Nullable int[] offsetInWindow, @NestedScrollType int type) {
        if (isNestedScrollingEnabled()) {
            final ViewParent parent = getNestedScrollingParentForType(type);
            if (parent == null) {
                return false;
            }
            if (dx != 0 || dy != 0) {
                ...
                consumed[0] = 0;
                consumed[1] = 0;
                ViewParentCompat.onNestedPreScroll(parent, mView, dx, dy, consumed, type);
								...
            } 
            ...
        }
        return false;
    }
</code></pre>
<p>所以如果直接在 RecyclerView 的外层套 <code>NestedScrollView</code> 是没有办法实现完整的嵌套滑动的，你会发现在上滑的时候，没有嵌套滑动的效果，而下滑的时候有嵌套滑动的效果。</p>
<h5 id="没有考虑到的问题">没有考虑到的问题</h5>
<p>其实，在之前所说的内容中，默认了手指从子 Viw 开始滑动。假如手指从外层的父 View 开始滑动，当父 View fling 到顶后，子 View 是无法继续 fling，会立马停住，无法实现连贯的嵌套滑动。</p>
<p>这是因为嵌套滑动组件中，位移的消费只能从 <code>NestedScrollingChild</code> 到 <code>NestedScrollingParent</code>，而不能从 <code>NestedScrollingParent</code> 到  <code>NestedScrollingChild</code> ，因为只有 <code>NestedScrollingChild</code> 才能 dispatch，<code>NestedScrollingParent</code> 不能 dispatch。</p>
<p>如果想要实现从 <code>NestedScrollingParent</code> 到  <code>NestedScrollingChild</code>  连贯的滑动，暂时没有特别好的办法，只能重写父 View 的事件分发，将父 View 滑动到顶后剩余的位移手动分发给它的子 View。(先挖个坑，看看有没有更好的办法，可以通过扩展嵌套滑动组件达到目的）</p>
<h5 id="tips">Tips</h5>
<p><code>NestedScrollingParent</code> 和 <code>NestedScrollingChild</code> 一共有 3 个版本。</p>
<p>最早的是 <code>NestedScrollingParent</code> 和 <code>NestedScrollingChild</code>，这一套接口把 scroll 和 fling 分别进行处理，造成了不必要的复杂性。</p>
<p>后来有了 <code>NestedScrollingParent2</code> 和 <code>NestedScrollingChild2</code> 继承自一代，不过它将 fling 转化为 scroll 的距离统一进行处理。上述的嵌套滑动组件均指二代。</p>
<p>再后来又有了 <code>NestedScrollingParent3</code> 和 <code>NestedScrollingChild</code> 继承自二代，它们相比于 2 代增加了 <code>dispatchNestedScroll</code> 和 <code>onNestedScroll</code> 消耗部分滑动位移的功能，即在父 View 消耗位移之后，将消耗值放入 <code>consumed</code> 数组通知子 View。而二代是不会让子 View 知道父 View 的消耗值的。一般来说，要自己实现嵌套滑动，只需要实现 2 代及以上接口即可。一代基本不再使用。</p>
<p><strong>注意</strong>：使用 <code>NestedScrollView</code> 有一个地方需要注意，当它的子 View 是 RecyclerView 这种 content 可以无限长的布局时，要注意限制这些子 View 的高度，不要使用 <code>wrap_content</code> 设置 RecyclerView 的高度。因为 <code>NestedScrollView</code> 在测量时给子 View 的限制是 <code>UNSPECIFIED</code>  ，即不做限制，RecyclerView 想要多高就有多高。像 RecyclerView 如果内部 item 数量太多，RecyclerView 在 <code>wrap_content</code> 的情况下会把所有 item 都显示出来，相当于没有回收。这样会对内存造成很大消耗。如果调用 <code>setVisibility</code> 改变可见性的话，当从不可见到可见，更是会瞬间调用所有 item 的测量布局流程，造成卡顿。这是我在项目中实际遇到的问题。</p>
<h3 id="三-多级嵌套滑动">三、多级嵌套滑动</h3>
<p>我们知道了 <code>NestedScrollingParent</code> 和 <code>NestedScrollingChild</code>可以用来定制化地实现自己地嵌套滑动。很容易想到，如果一个 View 同时实现了两个接口，那么它既可以接受 child 的滑动，又可以分发滑动给 parent，这样就形成了一个链条。而多级嵌套滑动的核心原理就来自于此，如图：</p>
<figure data-type="image" tabindex="3"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04651fef68e34951bc4bff6c90c11103~tplv-k3u1fbpfcp-watermark.image" alt="image-20210304170155409.png" loading="lazy"></figure>
<p>原理其实并不复杂，下面用伪代码表示一下：</p>
<ul>
<li>
<p>对于 <code>NestedScrollingParent</code></p>
<pre><code> @Override
    public void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed, int type) {
       scrollByMe(dx, dy);
       ...
       consumed[0] = dxConsumed;
       consumed[1] = dyConsumed;
    }
</code></pre>
</li>
<li>
<p>对于中介者，即同时实现了 <code>NestedScrollingParent</code> 和 <code>NestedScrollingChild</code> 的中间 View 来说</p>
<pre><code class="language-java"> @Override
    public void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed, int type) {
        // 先分发，再消费。当然也可以先以先消费，再分发，这取决于业务
       dispatchNestedPreScroll(dispatchNestedPreScroll(dx, dy, consumed, null, type);
	   	 int dx -= consumed[0];
       int dy -= consumed[1];
       scrollByMe(dx, dy);
       consumed[0] = dxConsumed;
       consumed[1] = dyConsumed;
    }
</code></pre>
</li>
<li>
<p>对于最内层的 <code>NestedScrollingChild</code>，一般使用 RecyclerView 就可以。<br>
在多级嵌套滑动中，可以根据业务自己设置各层在上滑与下滑过程中的优先级。</p>
</li>
</ul>
<p>工作的项目因为还没发布就不放上来了，这里上一个从网上找到的即刻 App 多级嵌套滑动的图：</p>
<figure data-type="image" tabindex="4"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd9239d5d70545bd830d304e88e4af0a~tplv-k3u1fbpfcp-watermark.image" alt="3b1169d0-23cd-11eb-a910-368fe856f9f2.gif" loading="lazy"></figure>
<p>可以参考这篇文章：https://zhuanlan.zhihu.com/p/56582475</p>
<h3 id="四-嵌套滑动组件中使用的设计模式">四、嵌套滑动组件中使用的设计模式</h3>
<p>作为总结，讨论一下。</p>
<ul>
<li>
<p><strong>策略模式</strong></p>
<p><code>NestedScrollingParent</code> 和 <code>NestedScrollingChild</code>是一对接口，不同的 View 通过实现这对接口来达到不同的嵌套滑动效果。同时使用接口也保证了扩展性。</p>
</li>
<li>
<p><strong>代理模式</strong></p>
<p>如前述，当一个 View 实现嵌套滑动接口中的方法时，滑动的具体传递都交给了代理的 <code>NestedScrollingParentHelper</code> 和 <code>NestedScrollingChildHelper</code>来实现，这两个类是由 sdk 提供的，在 <code>NestedScrollingParent</code> 和 <code>NestedScrollingChild</code> 接口中有如下说明：</p>
<pre><code class="language-java">This interface should be implemented by ViewGroup subclasses
that wish to support scrolling operations delegated by a nested child view.
Classes implementing this interface should create a final instance of a
NestedScrollingParentHelper as a field and delegate any View or ViewGroup methods
to the NestedScrollingParentHelper methods of the same signature.
</code></pre>
</li>
<li>
<p><strong>适配器模式 / 外观模式</strong></p>
<p>RecyclerView 实现了 <code>NestedScrollingChild2</code> 接口，但是如果它的父 view 实现的是一代的 <code>NestedScrollingParent</code> 接口怎么办？这就不同版本的嵌套滑动组件需要兼容。怎样实现兼容呢，使用 <code>ViewCompat</code> ，如下：</p>
<pre><code class="language-java">// ViewCompat.java
public static void onNestedPreScroll(ViewParent parent, View target, int dx, int dy,
            int[] consumed, int type) {
        if (parent instanceof NestedScrollingParent2) {
            // First try the NestedScrollingParent2 API
            ((NestedScrollingParent2) parent).onNestedPreScroll(target, dx, dy, consumed, type);
        } else if (type == ViewCompat.TYPE_TOUCH) {
            // Else if the type is the default (touch), try the NestedScrollingParent API
            if (Build.VERSION.SDK_INT &gt;= 21) {
                try {
                    parent.onNestedPreScroll(target, dx, dy, consumed);
                } catch (AbstractMethodError e) {
                    Log.e(TAG, &quot;ViewParent &quot; + parent + &quot; does not implement interface &quot;
                            + &quot;method onNestedPreScroll&quot;, e);
                }
            } else if (parent instanceof NestedScrollingParent) {
                ((NestedScrollingParent) parent).onNestedPreScroll(target, dx, dy, consumed);
            }
        }
    }
</code></pre>
<p>所有的 child 的滑动分发，都会通过 <code>ViewCompat</code> 的静态方法最终再传递给 parent，通过这个类以及静态方法，达到了不同版本嵌套滑动组件的兼容。同时， <code>ViewCompat</code> 对外暴露了易用的接口，而把兼容的过程隐藏在了自己内部，也可以看成是一种外观模式。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一文读懂 kotlin 的协变与逆变 -- 从 Java 说起]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/yi-wen-du-dong-kotlin-de-xie-bian-yu-ni-bian-cong-java-shuo-qi/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/yi-wen-du-dong-kotlin-de-xie-bian-yu-ni-bian-cong-java-shuo-qi/">
        </link>
        <updated>2020-10-10T12:50:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>为了更好地理解 kotlin 和 Java 中的协变与逆变，先看一些基础知识。</p>
<h4 id="普通赋值">普通赋值</h4>
<p>在 Java 中，常见的赋值语句如下：</p>
<pre><code class="language-java">A a = b;
</code></pre>
<p>赋值语句必须满足的条件是：左边要么是右边的父类，要么和右边类型一样。即 A 的类型要“大于”B 的类型，比如 <code>Object o = new String(&quot;s&quot;);</code> 。为了方便起见，下文中称作 A &gt; B。</p>
<p>除了上述最常见的赋值语句，还有两种其他的赋值语句：</p>
<h4 id="函数参数的赋值">函数参数的赋值</h4>
<pre><code class="language-java">public void fun(A a) {}
// 调用处赋值
B b = new B();
fun(b);
</code></pre>
<p>在调用 fun(b) 方法时，会将传入的 B b 实参赋值给形参 A a，即 <code>A a = b</code> 的形式。同样的，必须要满足形参类型大于实参，即 A &gt; B。</p>
<h4 id="函数返回值的赋值">函数返回值的赋值</h4>
<pre><code class="language-java">public A fun() {
    B b = new B();
    return b;
} 
</code></pre>
<p>函数返回值类型接收实际返回类型的值，实际返回类型 B b 相当于赋值给了函数返回值类型 A a，即 B b 赋值给了 A a, 即 <code>A a = b</code>，那么必须满足 A &gt; B 的类型关系。</p>
<p>所以，无论哪种赋值，都必须满足左边类型 &gt; 右边类型，即 A &gt; B。</p>
<h3 id="java-中的协变与逆变">Java 中的协变与逆变</h3>
<p>有了前面的基础知识，就可以方便地解释协变与逆变了。</p>
<p>如果类 A &gt; 类 B，经过一个变化 trans 后得到的 trans(A) 与 trans(B) 依旧满足 trans(A) &gt; trans(B)，那么称为<strong>协变</strong>。</p>
<p>逆变则刚好相反，如果类 A &gt; 类 B，经过一个变化 trans 后得到的 trans(A) 与 trans(B) 满足 trans(B) &gt; trans(A)，称为<strong>逆变</strong>。</p>
<p>比如大家都知道 Java 的数组是协变的，假如 A &gt; B，那么有 A[] &gt; B[]，所以 B[] 可以赋值给 A[]。举个例子：</p>
<pre><code class="language-java">Integer[] nums = new Integer[]{};
Object[] o = nums; // 可以赋值，因为数组的协变特性所以由 Object &gt; Integer 得到 Object[] &gt; Integer[]
</code></pre>
<p>但是 Java 的泛型则不满足协变，如下：</p>
<pre><code class="language-java">List&lt;Integer&gt; l = new ArrayList&lt;&gt;();
List&lt;Object&gt; o = l;// 这里会报错，不能编译
</code></pre>
<p>上述代码报错，就是因为，虽然 Object &gt; Integer，但是由于泛型不满足协变，所以 <code>List&lt;Object&gt;</code> &gt; <code>List&lt;Integer&gt;</code> 是不满足的，既然不满足左边大于右边这个条件，从前言中我们知道，自然就不能将 List&lt;Integer&gt; 赋值给 List&lt;Object&gt;。一般称 Java 泛型不支持型变。</p>
<h3 id="java-中泛型如何实现协变与逆变">Java 中泛型如何实现协变与逆变</h3>
<p>从前面我们知道，在 Java 中泛型是不支持型变的，但是这会产生一个让人很奇怪的疑惑，也是很多讲泛型的文章中提到的：</p>
<p>如果 B 是 A 的子类，那么 List&lt;B&gt; 就应该是 List&lt;A&gt; 的子类呀！这是一个非常自然而然的想法！</p>
<p>但是很抱歉，由于种种原因，Java 并不支持。但是，Java 并不是完全抹杀了泛型的型变特性，Java 提供了 &lt;? extends T&gt; 和 &lt;? super T&gt; 使泛型拥有协变和逆变的特性。</p>
<h4 id="extends-t-与-super-t">&lt;? extends T&gt; 与 &lt;? super T&gt;</h4>
<p>&lt;? extends T&gt; 称为上界通配符，&lt;? super T&gt; 称为下界通配符。使用上界通配符可以使泛型协变，而使用下界通配符可以使泛型逆变。</p>
<p>比如之前举的例子</p>
<pre><code class="language-java">List&lt;Integer&gt; l = new ArrayList&lt;&gt;();
List&lt;Object&gt; o = l;// 这里会报错，不能编译
</code></pre>
<p>如果使用上界通配符，</p>
<pre><code class="language-java">List&lt;Integer&gt; l = new ArrayList&lt;&gt;();
List&lt;? extends Object&gt; o = l;// 可以通过编译
</code></pre>
<p>这样，List&lt;? extends Object&gt; 的类型就大于 List&lt;Integer&gt; 的类型了，也就实现了协变。这也就是所谓的“子类的泛型是泛型的子类”。</p>
<p>同样，下界通配符 &lt;? super T&gt; 可以实现逆变，如：</p>
<pre><code class="language-java">public List&lt;? super Integer&gt; fun(){
    List&lt;Object&gt; l = new ArrayList&lt;&gt;();
    return l;
}
</code></pre>
<p>上述代码怎么就实现逆变了呢？首先，Object &gt; Integer；另外，从前言我们知道，函数返回值类型必须大于实际返回值类型，在这里就是 <code>List&lt;? super Integer&gt;</code> &gt; <code>List&lt;Object&gt;</code>，和 Object &gt; Integer 刚好相反。也就是说，经过泛型变化后，Object 和 Integer 的类型关系翻转了，这就是逆变，而实现逆变的就是下界通配符 &lt;? super T&gt;。</p>
<p>从上面可以看出，&lt;? extends T&gt; 中的上界是 T，也就是说 &lt;? extends T&gt; 所泛指的类型都是 T 的子类或 T 本身，所以 T 大于 &lt;? extends T&gt; 。&lt;? super T&gt; 中的下界是 T，也就是说 &lt;? super T&gt; 所泛指的类型都是 T 的父类或 T 本身，所以 &lt;? super T&gt;  大于 T。</p>
<p>虽然 Java 使用通配符解决了泛型的协变与逆变的问题，但是由于很多讲到泛型的文章都晦涩难懂，曾经让我一度感慨这 tm 到底是什么玩意？直到我在 stackoverflow 上发现了通俗易懂的解释(是的，前文大部分内容都来自于 stackoverflow 中大神的解释)，才终于了然。其实只要抓住<strong>赋值语句左边类型必须大于右边类型</strong>这个关键点一切就都很好懂了。</p>
<h4 id="pecs">PECS</h4>
<p>PECS 准则即 Producer Extends Consumer Super，生产者使用上界通配符，消费者使用下界通配符。直接看这句话可能会让人很疑惑，所以我们追本溯源来看看为什么会有这句话。</p>
<p>首先，我们写一个简单的泛型类：</p>
<pre><code class="language-java">public class Container&lt;T&gt; {
    private T item;

    public void set(T t) { 
        item = t;
    }

    public T get() {
        return item;
    }
}
</code></pre>
<p>然后写出如下代码：</p>
<pre><code class="language-java">Container&lt;Object&gt; c = new Container&lt;String&gt;(); // (1)编译报错

Container&lt;? extends Object&gt; c = new Container&lt;String&gt;(); // (2)编译通过
c.set(&quot;sss&quot;); // (3)编译报错
Object o = c.get();// (4)编译通过
</code></pre>
<p>代码 (1)，<code>Container&lt;Object&gt; c = new Container&lt;String&gt;();</code> 编译报错，因为泛型是不型变的，所以 Container&lt;String&gt; 并不是 Container&lt;Object&gt; 的子类型，所以无法赋值。</p>
<p>代码 (2)，加了上界通配符以后，支持泛型协变，Container&lt;String&gt; 就成了 Container&lt;? extends Object&gt; 的子类型，所以编译通过，可以赋值。</p>
<p>既然代码 (2) 通过编译，那代码 (3) 为什么会报错呢？因为代码 (3) 尝试把 String 类型赋值给 &lt;? extends Object&gt; 类型。显然，编译器只知道 &lt;? extends Object&gt;  是 Obejct 的某一个子类型，但是具体是哪一个并不知道，也许并不是 String 类型，所以不能直接将 String 类型赋值给它。</p>
<p>从上面可以看出，对于使用了 &lt;? extends T&gt; 的类型，是不能写入元素的，不然就会像代码 (3) 处一样编译报错。</p>
<p>但是可以读取元素，比如代码 (4) 。并且该类型只能读取元素，这就是所谓的“生产者”，即<strong>只能从中读取元素的就是生产者</strong>，生产者就使用 &lt;? extends T&gt; 通配符。</p>
<p>消费者同理，代码如下：</p>
<pre><code class="language-java">Container&lt;String&gt; c = new Container&lt;Object&gt;(); // (1)编译报错

Container&lt;? super String&gt; c = new Container&lt;Object&gt;(); // (2)编译通过
 c.set(&quot;sss&quot;);// (3) 编译通过
 String s = c.get();// (4) 编译报错

</code></pre>
<p>代码 (1) 编译报错，因为泛型不支持逆变。而且就算不懂泛型，这个代码的形式一眼看起来也是错的。</p>
<p>代码 (2) 编译通过，因为加了 &lt;? super T&gt; 通配符后，泛型逆变。</p>
<p>代码 (3) 编译通过，它把 String 类型赋值给 &lt;? super String&gt;，&lt;? super String&gt; 泛指 String 的父类或 String，所以这是可以通过编译的。</p>
<p>代码 (4) 编译报错，因为它尝试把 &lt;? super String&gt; 赋值给 String，而 &lt;? super String&gt; 大于 String，所以不能赋值。事实上，编译器完全不知道该用什么类型去接受 <code>c.get()</code> 的返回值，因为在编译器眼里 &lt;? super String&gt; 是一个泛指的类型，所有 String 的父类和 String 本身都有可能。</p>
<p>同样从上面代码可以看出，对于使用了 &lt;? super T&gt; 的类型，是不能读取元素的，不然就会像代码 (4) 处一样编译报错。但是可以写入元素，比如代码 (3)。该类型只能写入元素，这就是所谓的“消费者”，即<strong>只能写入元素的就是消费者</strong>，消费者就使用 &lt;? super T&gt; 通配符。</p>
<p>综上，这就是 PECS 原则。</p>
<h3 id="kotlin-中的协变与逆变">kotlin 中的协变与逆变</h3>
<p>kotlin 抛弃了 Java 中的通配符，转而使用了<strong>声明处型变</strong>与<strong>类型投影</strong>。</p>
<h4 id="声明处型变">声明处型变</h4>
<p>首先让我们回头看看 Container 的定义：</p>
<pre><code class="language-java">public class Container&lt;T&gt; {
    private T item;

    public void set(T t) { 
        item = t;
    }

    public T get() {
        return item;
    }
}
</code></pre>
<p>在某些情况下，我们只会使用 <code>Container&lt;? extends T&gt;</code> 或者 <code>Container&lt;? super T&gt;</code> ，意味着我们只使用 Container 作为生产者或者 Container 作为消费者。</p>
<p>既然如此，那我们为什么要在定义 Container 这个类的时候要把 get 和 set 都定义好呢？试想一下，如果一个类只有消费者的作用，那定义 get 方法完全是多余的。</p>
<p>反过来说，如果一个泛型类只有生产者方法，比如下面这个例子（来自 kotlin 官方文档）:</p>
<pre><code class="language-kotlin">// Java
interface Source&lt;T&gt; {
  T nextT(); // 只有生产者方法
}
// Java
void demo(Source&lt;String&gt; strs) {
  Source&lt;Object&gt; objects = strs; // ！！！在 Java 中不允许，要使用上界通配符 &lt;? extends Object&gt;
  // ……
}
</code></pre>
<p>在 <code>Source&lt;Object&gt;</code> 类型的变量中存储 <code>Source&lt;String&gt;</code> 实例的引用是极为安全的——因为没有消费者-方法可以调用。然而 Java 依然不让我们直接赋值，需要使用上界通配符。</p>
<p>但是这是毫无意义的，使用通配符只是把类型变得更复杂，并没有带来额外的价值，因为能调用的方法还是只有生产者方法。但 Java 编译器只认死理。</p>
<p>所以，如果我们能在使用之前确定一个类是生产者还是消费者，那在定义类的时候直接声明它的角色岂不美哉？</p>
<p>这就是 kotlin 的声明处型变，直接在类声明的时候，定义它的型变行为。</p>
<p>比如：</p>
<pre><code class="language-java">class Container&lt;out T&gt; { // (1)
    private  var item: T? = null 
        
    fun get(): T? = item
}

val c: Container&lt;Any&gt; = Container&lt;String&gt;()// （2）编译通过，因为 T 是一个 out-参数
</code></pre>
<p>(1) 处直接使用 &lt;out T&gt; 指定 T 类型只能出现在生产者的位置上。虽然多了一些限制，但是，在 kotlin 编译器在知道了 T 的角色以后，就可以像 (2) 处一样将 Container&lt;String&gt; 直接赋值给 Container&lt;Any&gt;，好像<strong>泛型直接可以协变了一样</strong>，而不需要再使用 Java 当中的通配符 &lt;? extends String&gt;。</p>
<p>同样的，对于消费者来说，</p>
<pre><code class="language-kotlin">class Container&lt;in T&gt; { // (1) 
    private  var item: T? = null 
     fun set(t: T) {
        item = t
    }
}

val c: Container&lt;String&gt; = Container&lt;Any&gt;() // (2) 编译通过,因为 T 是一个 in-参数
</code></pre>
<p>代码 (1) 处使用 &lt;in T&gt; 指定 T 类型只能出现在消费者的位置上。代码 (2) 可以编译通过， Any &gt; String，但是 Container&lt;String&gt; 可以被 Container&lt;Any&gt; 赋值，意味着 Container&lt;String&gt; 大于 Container&lt;Any&gt; ，即它看上去就像 <strong>T 直接实现了泛型逆变</strong>，而不需要借助 &lt;? super String&gt; 通配符来实现逆变。如果是 Java 代码，则需要写成 <code>Container&lt;? super String&gt; c = new Container&lt;Object&gt;();</code>。</p>
<p>这就是<strong>声明处型变</strong>，在类声明的时候使用 out 和 in 关键字，在使用时可以直接写出泛型型变的代码。</p>
<p>而 Java 在使用时必须借助通配符才能实现泛型型变，这是<strong>使用处型变</strong>。</p>
<h4 id="类型投影">类型投影</h4>
<p>有时一个类既可以作生产者又可以作消费者，这种情况下，我们不能直接在 T 前面加 in 或者 out 关键字。比如：</p>
<pre><code class="language-kotlin">class Container&lt;T&gt; {
    private  var item: T? = null
    
    fun set(t: T？) {
        item = t
    }

    fun get(): T? = item
}
</code></pre>
<p>考虑这个函数：</p>
<pre><code class="language-kotlin">fun copy(from: Container&lt;Any&gt;, to: Container&lt;Any&gt;) {
    to.set(from.get())
}
</code></pre>
<p>当我们实际使用该函数时：</p>
<pre><code class="language-kotlin">val from = Container&lt;Int&gt;()
val to = Container&lt;Any&gt;()
copy(from, to) // 报错，from 是 Container&lt;Int&gt; 类型，而 to 是 Container&lt;Any&gt; 类型
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ultimateHandsomeBoy666.github.io//post-images/1615726536879.png" alt="" loading="lazy"></figure>
<p>这样使用的话，编译器报错，因为我们把两个不一样的类型做了赋值。用 kotlin 官方文档的话说，copy 函数在”干坏事“， 它尝试<strong>写</strong>一个 Any 类型的值给 to， 而我们用 Int 类型来接收这个值，如果编译器不报错，那么运行时将会抛出一个 <code>ClassCastException</code> 异常。</p>
<p>所以应该怎么办？直接防止 from 被写入就可以了！</p>
<p>将 copy 函数改为如下所示：</p>
<pre><code class="language-kotlin">fun copy(from: Container&lt;out Any&gt;, to: Container&lt;Any&gt;) { // 给 from 的类型加了 out
    to.set(from.get())
}
val from = Container&lt;Int&gt;()
val to = Container&lt;Any&gt;()
copy(from, to) // 不会再报错了
</code></pre>
<p>这就是<strong>类型投影</strong>：from 是一个受限制的（<strong>投影的</strong>）Container 类，我们只能把它当作生产者来使用，它只能调用 get() 方法。</p>
<p>同理，如果 from 的泛型是用 in 来修饰的话，则 from 只能被当作消费者使用，它只能调用 set() 方法，上述代码就会报错：</p>
<pre><code class="language-kotlin">fun copy(from: Container&lt;in Any&gt;, to: Container&lt;Any&gt;) { // 给 from 的类型加了 in
    to.set(from.get())
}
val from = Container&lt;Int&gt;()
val to = Container&lt;Any&gt;()
copy(from, to) //  报错
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ultimateHandsomeBoy666.github.io//post-images/1615726448076.png" alt="" loading="lazy"></figure>
<p>其实从上面可以看到，类型投影和 Java 的通配符很相似，也是一种<strong>使用时型变</strong>。</p>
<h3 id="为什么要这么设计">为什么要这么设计？</h3>
<p>为什么 Java 的数组是默认型变的，而泛型默认不型变呢？其实 kolin 的泛型默认也是不型变的，只是使用 out 和 in 关键字让它看起来像泛型型变。</p>
<p>为什么这么设计呢？为什么不默认泛型可型变呢？</p>
<p>在 stackoverflow 上找到了答案，参考：https://stackoverflow.com/questions/18666710/why-are-arrays-covariant-but-generics-are-invariant</p>
<blockquote>
<p>Java 和 C# 早期都是没有泛型特性的。</p>
<p>但是为了支持程序的多态性，于是将数组设计成了协变的。因为数组的很多方法应该可以适用于所有类型元素的数组。</p>
<p>比如下面两个方法：</p>
<pre><code class="language-java">boolean equalArrays (Object[] a1, Object[] a2);
void shuffleArray(Object[] a);
</code></pre>
<p>第一个是比较数组是否相等；第二个是打乱数组顺序。</p>
<p>语言的设计者们希望这些方法对于任何类型元素的数组都可以调用，比如我可以调用 shuffleArray(String[] s) 来把字符串数组的顺序打乱。</p>
<p>出于这样的考虑，在 Java 和 C# 中，数组设计成了协变的。</p>
<p>然而，对于泛型来说，却有以下问题：</p>
<pre><code class="language-java">// Illegal code - because otherwise life would be Bad
List&lt;Dog&gt; dogs = new List&lt;Dog&gt;();
List&lt;Animal&gt; animals = dogs; // Awooga awooga
animals.add(new Cat());// (1)
Dog dog = dogs.get(0); //(2) This should be safe, right?
</code></pre>
<p>如果上述代码可以通过编译，即 List&lt;Dog&gt; 可以赋值给 List&lt;Animal&gt;，List 是协变的。接下来往 List&lt;Dog&gt; 中 add 一个 Cat()，如代码 (1) 处。这样就有可能造成代码 (2) 处的接收者 <code>Dog dog</code> 和 <code>dogs.get(0)</code> 的类型不匹配的问题。会引发运行时的异常。所以 Java 在编译期就要阻止这种行为，把泛型设计为默认不型变的。</p>
</blockquote>
<h3 id="总结">总结</h3>
<p>1、Java 泛型默认不型变，所以 List&lt;String&gt; 不是 List&lt;Object&gt; 的子类。如果要实现泛型型变，则需要 &lt;? extends T&gt; 与 &lt;? super T&gt; 通配符，这是一种使用处型变的方法。使用 &lt;? extends T&gt; 通配符意味着该类是生产者，只能调用 get(): T 之类的方法。而使用 &lt;? super T&gt; 通配符意味着该类是消费者，只能调用 set(T t)、add(T t) 之类的方法。</p>
<p>2、Kotlin 泛型其实默认也是不型变的，只不过使用 out 和 in 关键字在类声明处型变，可以达到在使用处看起来像直接型变的效果。但是这样会限制类在声明时只能要么作为生产者，要么作为消费者。</p>
<p>使用类型投影可以避免类在声明时被限制，但是在使用时要使用 out 和 in 关键字指明这个时刻类所充当的角色是消费者还是生产者。类型投影也是一种使用处型变的方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的最近公共祖先]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/er-cha-shu-de-zui-jin-gong-gong-zu-xian/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/er-cha-shu-de-zui-jin-gong-gong-zu-xian/">
        </link>
        <updated>2020-06-11T12:49:20.000Z</updated>
        <content type="html"><![CDATA[<p>该题来自 leetcode 236， https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</p>
<h3 id="题目">题目</h3>
<p>给定一个二叉树, 找到该树中两个指定节点 p、q 的最近公共祖先。</p>
<h3 id="分析">分析</h3>
<p>首先设 p、q 的最近公共祖先为 root。这个题目最关键的地方在于理解以下两点：</p>
<blockquote>
<ul>
<li>要么 p，q 两个节点只在 root 的一个子树上，此时 root 必然就是 p、q 中深度小的那个，即 root == p || root == q</li>
<li>要么 p，q 两个节点分别在 root 的两个子树上</li>
</ul>
</blockquote>
<p>下面先来证明第一点：</p>
<blockquote>
<p>p，q 两个节点只在最近公共祖先 root 的一个子树上，此时 root 必然就是 p、q 中深度小的那个，即 root == p || root == q</p>
</blockquote>
<p>使用反证法。<br>
假设 p，q 两个节点只在最近公共祖先 root 的一个子树上，且 root != p &amp;&amp; root != q，如下图：<br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615726225557.png" alt="" loading="lazy"><br>
很明显，此时 p、q 的最近公共祖先为 root'，而非 root。并且 p、q 也分别 root' 的两个子树上。这与 <strong>root 是最近公共祖先</strong>，以及，<strong>p、q 同在 root' 的一个子树上</strong>的假设矛盾。</p>
<p>第二点则非常容易理解，如果 p、q 不同在 root 的一个子树上，则必然分别在两个子树上。</p>
<p>理解了这两点有什么用呢？<br>
这两点可以有下面的推论：</p>
<blockquote>
<ul>
<li>假设 root 为 p、q 的任一公共父节点，如果 p 、q 分别在 root 的左右子树上，则 root 必为 p、q 最近公共祖先。（可由上述第一点反证推出）</li>
<li>对于 p、q 的所有公共父节点， 如果 p、q 均不分别在其左右子树，而是同在其一颗子树上，则 p、q 的最近公共节点一定是 p、q 中深度较小的那个。</li>
</ul>
</blockquote>
<p>记住了上面这两点，就可以写出非常简洁的递归代码：</p>
<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root;// 保证遍历完所有可能的 p、q 公共父节点
        TreeNode left = lowestCommonAncestor(root.left, p, q); // 如果 left != null，则 p 或 q 在 root 的左子树中
        TreeNode right = lowestCommonAncestor(root.right, p, q); // // 如果 right != null，则 p 或 q 在 root 的右子树中
        if (left != null &amp;&amp; right != null) return root; // 如果 left != null &amp;&amp; right!= null，则对应推论第一点
        return left != null ? left : right; // 在遍历完所有可能的父节点后，p、q 均不分在父节点的左右两侧，对应推论第二点
    }
}
</code></pre>
<p>参考：<br>
https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-jian-j/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 中的 data class 和 sealed class]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/kotlin-zhong-de-data-class-he-sealed-class/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/kotlin-zhong-de-data-class-he-sealed-class/">
        </link>
        <updated>2020-05-20T12:47:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="kotlin-中的-data-class">Kotlin 中的 data class</h2>
<p>在使用 java 的时候，我们经常会重写类的 <code>equals</code> 、<code>hashCode</code> 和 <code>toString</code> 方法。这些方法往往都是模板化的。在 kotlin 中提供了更为简便的方法让我们使用一行代码搞定这些工作。这就是 <code>data class</code>。</p>
<pre><code class="language-kotlin">// 定义一个 Person 类
data class Person(val name: String, val age: Int) {
}
</code></pre>
<p>写好上面的代码之后，<code>Person</code> 类中的上述几个方法的重写就由 kotlin 帮我们自动完成了。运行下面的代码</p>
<pre><code class="language-kotlin">fun main() {
    val p1 = Person(&quot;Jack&quot;, 24)
    val p2 = Person(&quot;Jack&quot;, 24)

    val p3 = Person(&quot;Jack&quot;, 32)
    val p4 = Person(&quot;Rose&quot;, 31)

    println(p1 == p2) 

    println(p1 === p2)

    println(p1 == p3)

    println(&quot;&quot;&quot;
        p1 hashCode = ${p1.hashCode()}
        p2 hashCode = ${p2.hashCode()}
        p3 hashCode = ${p3.hashCode()}
        p4 hashCode = ${p4.hashCode()}
    &quot;&quot;&quot;.trimIndent())
    
    println(&quot;p1 = $p1&quot;)
}

</code></pre>
<p>结果如下：</p>
<pre><code>true
false
false
p1 hashCode = 71328761
p2 hashCode = 71328761
p3 hashCode = 71328769
p4 hashCode = 79149200
p1 = Person(name=Jack, age=24)
</code></pre>
<p>可以看到<code>equals</code> 、<code>hashCode</code> 和 <code>toString</code> 方法可以直接调用，并且已经被覆写了。</p>
<h2 id="data-class-究竟做了什么">data class 究竟做了什么？</h2>
<p><code>data class</code> 是如何做到上述实现的呢？查看 <code>Person</code> 类的字节码反编译得到的 java 代码，如下</p>
<pre><code class="language-java">public final class Person {
   @NotNull
   private final String name;
   private final int age;

   @NotNull
   public final String getName() {
      return this.name;
   }

   public final int getAge() {
      return this.age;
   }

   public Person(@NotNull String name, int age) {
      Intrinsics.checkParameterIsNotNull(name, &quot;name&quot;);
      super();
      this.name = name;
      this.age = age;
   }

   @NotNull
   public final String component1() {
      return this.name;
   }

   public final int component2() {
      return this.age;
   }

   @NotNull
   public final Person copy(@NotNull String name, int age) {
      Intrinsics.checkParameterIsNotNull(name, &quot;name&quot;);
      return new Person(name, age);
   }

   // $FF: synthetic method
   public static Person copy$default(Person var0, String var1, int var2, int var3, Object var4) {
      if ((var3 &amp; 1) != 0) {
         var1 = var0.name;
      }

      if ((var3 &amp; 2) != 0) {
         var2 = var0.age;
      }

      return var0.copy(var1, var2);
   }

   @NotNull
   public String toString() {
      return &quot;Person(name=&quot; + this.name + &quot;, age=&quot; + this.age + &quot;)&quot;;
   }

   public int hashCode() {
      String var10000 = this.name;
      return (var10000 != null ? var10000.hashCode() : 0) * 31 + this.age;
   }

   public boolean equals(@Nullable Object var1) {
      if (this != var1) {
         if (var1 instanceof Person) {
            Person var2 = (Person)var1;
            if (Intrinsics.areEqual(this.name, var2.name) &amp;&amp; this.age == var2.age) {
               return true;
            }
         }

         return false;
      } else {
         return true;
      }
   }
}
</code></pre>
<p>从上面可以一目了然地看见 kotlin 是如何构造 data class 的。由于我定义的成员变量是 <code>val</code> 不可变类型的，所以没有 Getter 和 Setter。</p>
<ul>
<li>
<p>对于<code>equals</code> 方法，对于 <code>var1</code> , 如果它的地址和自己不同，那么先检查其是否是 <code>Person</code> 类型 ，如果是，则逐个对比每个成员变量是否相等。这里用到的     <code>Intrinsics.areEqual(Object o1, Object o2)</code> 定义如下：</p>
<pre><code class="language-kotlin">public static boolean areEqual(Object first, Object second) {
      return first == null ? second == null : first.equals(second);
  }
</code></pre>
<p>最终调用了被比较对象的 <code>equals</code> 方法。<br>
对于 Int 类型的成员变量 <code>age</code> , 直接使用 <code>==</code> 比较。</p>
<p>这是覆写一个类的 <code>equals</code> 方法的常规写法。</p>
</li>
<li>
<p><code>hashCode</code> 和 <code>toString</code> 方法也是我们常规覆写的套路。</p>
</li>
<li>
<p>提供了 <code>component1</code> 和 <code>component2</code> 两个方法来获取成员变量。这两个方法可以用来做解构声明。如下：</p>
<pre><code class="language-kotlin">val (name, age) = Person(&quot;Rose&quot;, 43) 
println(&quot;$name, $age&quot;)
// (name, age) 就是解构声明，name 对应 component1 , age 对应 component2 
</code></pre>
</li>
<li>
<p>提供了 <code>copy</code> 方法构造一个 <code>Person</code> 对象。有 // $FF: synthetic method 注释的 <code>copy$default</code> 方法是给 kotlin 编译器调用的，我们用不到。</p>
<p>如果我们只想要 <code>age</code> 不同的 <code>Person</code> , 可以这样写</p>
<pre><code class="language-kotlin">  val newPerson = p1.copy(age = 30)
</code></pre>
<p>编译器编译到这句代码时，会帮我们调用 <code>copy$default</code> 来构造一个 <code>name</code> 值和 p1 一样的  <code>newPerson</code> 对象 。</p>
</li>
</ul>
<p>总之， <code>data class</code> 就是用常规套路来生成一个已经覆写好上述方法的类。</p>
<p>如果 Person 类不需要自动生成 age ，只需要把 age 从主构造函数中拿出，放到类体中就可以。如下</p>
<pre><code class="language-kotlin">data class Person(val name： String) {
    val age: Int = 0
}
</code></pre>
<h2 id="kotlin-中的-sealed-class">Kotlin 中的 sealed class</h2>
<p><code>sealed class</code> 是一种同时拥有枚举类 <code>enum</code> 和 普通类 <code>class</code> 特性的类，叫做密封类。使用起来很简单，如下</p>
<pre><code class="language-kotlin">sealed class Result
class Success(val code: Int) : Result()
class Exception(val code: Int, val message: String) : Result()
</code></pre>
<p>在同一个 kotlin 文件中声明三个类。首先声明 <code>sealed class</code> 类 <code>Result</code>, 然后定义出两个子类 <code>Success</code>, <code>Exception</code> 继承自 <code>Result</code>。注意，密封类及其子类必须声明在同一个 kotlin 文件中。</p>
<p>这是一个非常常见的场景。比如对于网络请求的结果 Result ， 往往只有两种类型，成功 Success 或者是失败 Exception 。使用普通的类不能把限制关系表达出来，使用枚举类则无法灵活地自定义需要的类的内容。这时候，<code>sealed class</code> 就派上用场了。比如在处理结果 <code>Result</code> 的时候:</p>
<pre><code class="language-kotlin">fun handleResult(result: Result): String{
    return when(result) {
        is Success -&gt; {
            &quot;success&quot;
        }
        is Exception -&gt; {
            &quot;exception&quot;
        }
    }
}
</code></pre>
<p>这样，对于 <code>handleResult</code> 的入参就做了类型的限制，防止传入类型不匹配的参数。</p>
<p>还有一个好处是，使用密封类的话，<code>when</code> 表达式可以覆盖所有情况，不需要再添加 <code>else</code> 语句（表达式即有返回值的 <code>when</code> , 没有返回值的称为 <code>when</code> 语句）。</p>
<h2 id="sealed-class-究竟做了什么">sealed class 究竟做了什么？</h2>
<p>同样地，让我们来看看 <code>sealed class</code> 在 java 层面做了什么，实现了前面的效果。<br>
上述密封类反编译得到的 java 代码如下：</p>
<pre><code class="language-java">public final class Exception extends Result {
   private final int code;
   @NotNull
   private final String message;

   public final int getCode() {
      return this.code;
   }

   @NotNull
   public final String getMessage() {
      return this.message;
   }

   public Exception(int code, @NotNull String message) {
      Intrinsics.checkParameterIsNotNull(message, &quot;message&quot;);
      super((DefaultConstructorMarker)null);
      this.code = code;
      this.message = message;
   }
}
// Success.java
import kotlin.Metadata;
import kotlin.jvm.internal.DefaultConstructorMarker;
public final class Success extends Result {
   private final int code;

   public final int getCode() {
      return this.code;
   }

   public Success(int code) {
      super((DefaultConstructorMarker)null);
      this.code = code;
   }
}
// Result.java
import kotlin.Metadata;
import kotlin.jvm.internal.DefaultConstructorMarker;
// 最重要的地方
public abstract class Result {
   private Result() {
   }

   // $FF: synthetic method
   public Result(DefaultConstructorMarker $constructor_marker) {
      this();
   }
}

</code></pre>
<p>可以看到，<code>Result</code> 类其实是一个抽象类，<code>Success</code> 和 <code>Exception</code> 继承了这个抽象类。<code>Result</code> 类的构造函数是私有的，不能在外部访问到。</p>
<p>通过继承这个抽象类，达到限制类型的做法。</p>
<p>这其实和 java 中使用接口来限定参数类型的做法类似，很好理解。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 中的扩展函数和扩展属性]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/kotlin-zhong-de-kuo-zhan-han-shu-he-kuo-zhan-shu-xing/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/kotlin-zhong-de-kuo-zhan-han-shu-he-kuo-zhan-shu-xing/">
        </link>
        <updated>2020-04-26T12:35:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="kotlin-扩展函数">Kotlin 扩展函数</h3>
<p>在 android 开发中，经常会使用到各种 utils 工具类。比如 ViewUtils， ScreenUtils， FileUtils 等，</p>
<p>这些类往往会提供一些静态方法，让我们进行一些通用的操作。</p>
<p>或者，我们常常会希望给某一个类增加一两个小属性或者方法，在用到这个类的地方都能调用，方便我们的开发。比如，我们希望每个 String 对象都能有一个方法，返回这个 String 对象包含的大写字母个数。</p>
<p>我们可能会在某个 utils 中这样写</p>
<pre><code class="language-java">public static int getStringCapitalCount(String s) throws Exception {
        if (s == null) {
            throw new Exception(&quot;string should not be null!&quot;);
        }
        int count = 0;
        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (c &gt;= 65 &amp;&amp; c &lt;= 90) {
                count++;
            }
        }
        return count;
    }
</code></pre>
<p>或者, 我们会考虑使用一个子类来继承这个父类，然后给子类添加这个方法，在代码中使用子类。当然，String 是不可继承的。</p>
<p>这样写，并没有什么问题，一贯的 java 写法。</p>
<p>但是在 Kotlin 中，我们有了更优雅的方式。既然我们最开始的目标是希望 String 类型多一个方法，那么我们的代码也应该写得像这样，如下：</p>
<pre><code class="language-kotlin">// 函数名以类名作为前缀： ClassName.funName
// 该前缀叫做 接收者类型（receiver type）
fun String.capitalCount(): Int{ 
    var count = 0
    this.forEach { // this 指的是类的实例对象, 叫 接收者对象（receiver object）
        if (it.toInt() in 65..90) {
            count ++
        }
    }
    return count
}
</code></pre>
<p>然后，我们可以在任何使用到 String 的地方，调用这个方法，就好像 String 类型本来就拥有这个方法一样。</p>
<pre><code class="language-kotlin">fun main() {
    val s = &quot;AbCdEfg&quot;
    println(s.capitalCount())
}
</code></pre>
<p>这就是 Kotlin 中的扩展函数。</p>
<p>一般，将扩展函数定义在一个 Extensions.kt 的文件中，最外层直接写函数就可以，不需要像 java 一样定义一个类。这样定义的函数是顶层函数，类似于 java 中的静态函数，可以在任何地方被调用。</p>
<figure data-type="image" tabindex="1"><img src="https://ultimateHandsomeBoy666.github.io//post-images/1615725849618.png" alt="" loading="lazy"></figure>
<p>类似地， 我们再写一个例子，比如经常用到的将 Date 转为 String 的函数，我们使用扩展函数的方式：</p>
<pre><code class="language-kotlin">fun Date.dateString(): String{
    val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())
    return dateFormat.format(this)
}

// 调用时
fun main() {
    println(Date().dateString())
}
</code></pre>
<p><strong>注意</strong></p>
<ul>
<li>
<p>扩展函数虽然看起来像是往类里面添加了成员函数，但是实际上并没有改变类的任何结构。所以，对于类内部 private、protected 以及 internal（模块外访问）修饰的成员变量和函数，是不能够访问到的，编译器会报错。</p>
<img src="file:///Users/bullfrog/Documents/Gridea/post-images/1615725879056.png" alt="Encapsulation of an Extension Function in Kotlin" style="zoom: 80%;" />
</li>
<li>
<p>如果扩展函数和类内部定义的成员函数重名，那么调用时执行的是类的函数。</p>
</li>
<li>
<p>扩展是静态解析的，调⽤的扩展函数是由函数调⽤所在的表达式的类型来决定的，⽽不是由表达式运⾏时求值结果决定的。例如：</p>
<pre><code class="language-kotlin">open class Shape
class Rectangle: Shape()
fun Shape.getName() = &quot;Shape&quot;
fun Rectangle.getName() = &quot;Rectangle&quot;
fun printClassName(s: Shape) {
println(s.getName())
}
printClassName(Rectangle())
</code></pre>
<p>这个例子会输出 “Shape” ，因为调用的扩展函数只取决于 s 参数的类型声明，这里它是 Shape 类。</p>
</li>
</ul>
<h3 id="kotlin-扩展属性">Kotlin 扩展属性</h3>
<p>和扩展函数类似，Kotlin 同样支持扩展属性。比如：</p>
<pre><code class="language-kotlin">// 给 StringBuilder 类添加扩展属性 firstLetter
var StringBuilder.firstLetter: Char
    get() = get(0)
    set(value) = this.setCharAt(0, value)
</code></pre>
<p>可以把扩展属性看作是两个扩展函数，一个是 getter， 一个是 setter 。</p>
<p>调用时：</p>
<pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;) {
    val message = StringBuilder(&quot;hello !&quot;)
    println(&quot;${message.firstLetter} is the first letter of $message&quot;)
    message.firstLetter = 'H'
    println(&quot;${message.firstLetter} is the first letter of $message&quot;)
}
</code></pre>
<p>输出结果：</p>
<blockquote>
<p>h is the first letter of hello !</p>
</blockquote>
<blockquote>
<p>H is the first letter of Hello !</p>
</blockquote>
<p><strong>注意</strong></p>
<p>扩展属性没有初始化器，即扩展属性不能初始化，只能使用 getter / setter 来操作扩展属性的值。</p>
<pre><code class="language-kotlin">val StringBuilder.firsetLetter = 'a' // 这是错误的， 不能初始化扩展属性
</code></pre>
<p>这是因为扩展属性并没有真正地插入一个属性到类中，所以扩展属性没有幕后字段（backing field），不能进行初始化。同样，也不能在扩展属性的 setter 里使用 field 关键字。</p>
<p><strong>配合泛型使用</strong></p>
<p>可以使用泛型来给多个类添加扩展属性。比如：</p>
<pre><code class="language-kotlin">// 得到逆序的 string
val &lt;T&gt; T.reverseString: String
    get() {
        return this.toString().reversed() // 实际上 reversed 函数也是 Kotlin String 类型自带的扩展函数
    }
</code></pre>
<h3 id="扩展的-java-代码">扩展的 Java 代码</h3>
<p>Kotlin 究竟是如何实现扩展函数和扩展属性的呢？</p>
<p>还是使用之前 String.capitalCount 的例子，反编译后的 java 代码如下：</p>
<pre><code class="language-java">// Extension.kt 文件会被编译成 ExtensionKt.class
public final class ExtensionsKt {
   public static final int capitalCount(@NotNull String $this$capitalCount) {
      int count = 0;
      CharSequence $this$forEach$iv = (CharSequence)$this$capitalCount;
      int $i$f$forEach = false;
      CharSequence var4 = $this$forEach$iv;

      for(int var5 = 0; var5 &lt; var4.length(); ++var5) {
         char element$iv = var4.charAt(var5);
         int var8 = false;
         if ('A' &lt;= element$iv) {
            if ('Z' &gt;= element$iv) {
               ++count;
            }
         }
      }
 return count;
}
</code></pre>
<p>实际上和在 java util 中实现方法一致，生成了一个以 String 类型为形参的静态方法，而函数形参 this$capitalCount 其实就是在 kotlin 中 this 指代的那个对象。</p>
<p>再看 StringBuilder.firstLetter 属性的反编译 java 代码：</p>
<pre><code class="language-java">public static final char getFirstLetter(@NotNull StringBuilder $this$firstLetter) {
      return $this$firstLetter.charAt(0);
   }

public static final void setFirstLetter(@NotNull StringBuilder $this$firstLetter, char value) {
      $this$firstLetter.setCharAt(0, value);
   }
</code></pre>
<p>其实就是生成了两个静态的方法，一个 setter 和 一个 getter。用两个扩展函数也可以达到同样的效果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[译文]怎么成为一名真正的键盘侠（从此不再使用鼠标）]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/yi-wen-zen-me-cheng-wei-yi-ming-zhen-zheng-de-jian-pan-xia-cong-ci-bu-zai-shi-yong-shu-biao/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/yi-wen-zen-me-cheng-wei-yi-ming-zhen-zheng-de-jian-pan-xia-cong-ci-bu-zai-shi-yong-shu-biao/">
        </link>
        <updated>2019-06-08T12:56:53.000Z</updated>
        <content type="html"><![CDATA[<p>原文地址：https://levelup.gitconnected.com/how-to-become-a-true-keyboard-warrior-and-stop-using-your-mouse-a87cd29c5801</p>
<figure data-type="image" tabindex="1"><img src="https://ultimateHandsomeBoy666.github.io//post-images/1615726654424.png" alt="键盘侠" loading="lazy"></figure>
<p>你肯定见到过程序员们面红耳赤地争论哪个 IDE 好用，哪个编程语言语法更牛 —— 这个争论可以扩展成我们现在要讨论的问题，即我们是怎样使用键鼠来操作电脑的。</p>
<p>按照使用电脑的方式，可以划分出两类人：一类很依赖鼠标，也不能理解为什么有人愿意用键盘输入代替鼠标来操作电脑；另一类人，就是我们（作者自夸），人数虽少，但是懂得用键盘的便捷之处，尽可能地使用键盘。</p>
<h2 id="一旦习惯了键盘以后你的速度会快得多">一旦习惯了键盘以后，你的速度会快得多</h2>
<p>使用鼠标并没有什么问题，但是假如你明确知道自己要做什么（而不是漫无目的地网上冲浪），那毫无疑问使用键盘是一个更快的选择。</p>
<p>举个大家都懂的简单例子，使用 <strong>Ctrl-C/V</strong> 进行复制粘贴操作，而不是鼠标右击，在众多的选项中找到复制，然后再把这个操作重复一遍，进行粘贴。几乎所有我认识的人都是很早就懂得使用键盘来进行复制/粘贴操作，即使是那些非 IT 岗的同事。</p>
<p>但这只是冰山一角，并且大部分人在 <strong>Ctrl-C/V</strong> 之前仍然需要用鼠标选中文字，而不是使用 <strong>Ctrl-Shift-方向键</strong> 或者是 <strong>Shift-End/Home</strong>。大部分人使用回退键删除打错的字母，而不会使用 <strong>Ctrl-Backspace</strong> 来删除整个单词再重新输入。还有许多人使用鼠标在程序窗口之间切换，而不是使用 <strong>Alt-Tab</strong> 组合键。</p>
<p>很难去解释为什么像用鼠标操作这么简简单单的事情，其实会浪费大量时间。而且大部分人并没有意识到，因为比起使用快捷键，鼠标操作多花的时间少得可怜。但是我可以向你保证，依赖鼠标的人，一天会多浪费一个小时，甚至更多的时间。用这些时间偷偷懒休息一下或者再做点工<br>
作，不香吗？</p>
<blockquote>
<p>每次你用鼠标，你都多花了十几二十秒 —— 这还不算用鼠标打断你工作节奏的代价。</p>
</blockquote>
<h2 id="使用键盘来操作文本">使用键盘来操作文本</h2>
<p>即使快捷键很简单，但是仍然有相当多人不知道这些基本的快捷操作。<br>
几乎所有的文本编辑器都可以让你做到下面这些基本的快捷操作，长期来看可以帮你省下几个小时的时间：</p>
<ul>
<li><strong>Ctrl-Backspace</strong>/<strong>Ctrl-Delete</strong> 可以直接把左/右的单词删除，不用一个字母一个字母的删。</li>
<li><strong>Shift</strong> 键加上方向键可以选中文字，再同时按下 <strong>Ctrl</strong> 键的话，就是以单词的跨度来选中。<strong>Shift</strong> 和 <strong>Home/End</strong> 键同时按，直接向前/后选中一整行，而不需要按住 <strong>Shift</strong> 逐词选中。这样你就可以用 <strong>Shift-Backspace-Home/End</strong> 直接删除前/后一整行。</li>
<li><strong>Ctrl-方向上键</strong> 在许多文本编辑器中可以往上跳一个段落，虽然我不经常用，但是这个小技巧确实可以比只用方向键更快。</li>
<li><strong>Ctrl-F</strong> 可以搜索单词，也可以让你快速地跳转到网页或者文档的某个部分，如果你知道自己在寻找什么的话。<strong>Ctrl-H</strong> 可以在同一个程序中打开相同的窗口并且替换掉单词/词组。</li>
<li><strong>Ctrl-Home/End</strong> 可以让你跳转到文档的开头/结尾，这个技巧很有用。比如你在某个地方做了更正，然后需要再返回文档结尾继续编辑，就可以使用这个快捷键。</li>
</ul>
<h2 id="浏览器的快捷操作">浏览器的快捷操作</h2>
<p>几乎所有我认识的人，都会依靠鼠标来操作浏览器，好像没有人知道其实你可以用 <strong>Ctrl-L</strong> 跳转到地址栏，然后直接输入你想访问的网址。</p>
<ul>
<li><strong>Ctrl-T</strong> 可以打开一个新的浏览器页面。</li>
<li><strong>Ctrl-W</strong> 可以关闭当前页面。</li>
<li><strong>Ctrl-1</strong> 到 8 可以按排列顺序打开相应的页面，<strong>Ctrl-9</strong> 则总是会跳转到最后一个页面。</li>
<li><strong>Ctrl-PageUp/PageDown</strong> 可以在打开的页面中逐个来回穿梭，<strong>PageUp/PageDown</strong> 则可以让你上下滚动页面。</li>
<li>说到滚动页面：你还可以用空格键往下滚动页面，很方便，尤其是你另一只手很忙的时候...端着水杯喝水，同时又能很好地工作。</li>
<li><strong>Ctrl-R</strong> 会重新加载页面，和 <strong>F5</strong> 功能一样。</li>
<li>浏览器的地址栏同时也是搜索栏，所以直接在地址栏里输入你要搜索的东西就可以啦，不需要先打开 <strong>google</strong>。</li>
</ul>
<h2 id="浏览器的高阶快捷操作">浏览器的高阶快捷操作</h2>
<p>这些操作需要你安装一个叫做 <strong>Vimium</strong> 的 chrome 浏览器插件，这玩意是自切面包机发明以来最好的东西了。</p>
<p>有了这个插件，你就可以在网站里自如穿梭，滚动页面，查找和点击链接，所有这些操作都不需要借助鼠标。如果你了解各类 IDE 如 VS/VSCode/Jetbrains 的多快捷键操作，那么这个插件会让你如虎添翼，而且这个插件学起来超快的！</p>
<p>比如在 VSCode 中，<strong>Ctrl-KD</strong> 这个快捷键代表着按住 <strong>Ctrl</strong> 键，然后按 <strong>K</strong> 和 <strong>D</strong>，这样你的代码就会自动整理成优美的格式。这个快捷键最开始有点令人迷惑，但是它已经成了我有生以来的最棒的快捷键之一，因为它意味着几乎所有我用的应用程序中的功能，都可以有对应的快捷操作，我可以把他们中我最需要的那些给记住。而且，如果我真的不记得的了话，我也可以用鼠标，在窗口，菜单栏，选项里随意搜索，直到我发现我需要的功能藏在哪里。</p>
<p>安装了 Vimium 以后，只需简单按下 “<strong>F</strong>” 然后网页就会变成这样：</p>
<figure data-type="image" tabindex="2"><img src="https://ultimateHandsomeBoy666.github.io//post-images/1615726671890.png" alt="为什么我老婆不再爱我了？" loading="lazy"></figure>
<p>然后只需要确定你要打开的链接，比如按下 “<strong>P</strong>” 键，你就能知道为什么你的老婆对你这么冷淡，却对隔壁那个懂得修理马桶的老王那么亲昵，可是他明明什么快捷键都不懂啊，比你差远啦！</p>
<p>还有许多好用的快捷键,但是我给你介绍的这些初级快捷键，也是我自己用得最多的。还有的，比如像 <strong>j/k</strong> 可以让你非常顺滑地滚动页面。如果你用空格键觉得滚动太快了，那不妨试试这个。</p>
<h2 id="我的电脑其实就是浏览器">“我的电脑”其实就是浏览器</h2>
<p>许多人没有意识到的是，“我的电脑”其实就是一个浏览器，浏览器的快捷键同样适用。</p>
<ul>
<li><strong>Win-E</strong> 打开文件管理器。</li>
<li><strong>Ctrl-L</strong> 可以让你跳转到地址栏，然后你可以输入文件地址。</li>
<li><strong>tab</strong>，<strong>shift</strong> 和方向键可以选中文件。<strong>F2</strong> 可以重命名。</li>
</ul>
<h2 id="除此以外是时候用上你的控制台了">除此以外，是时候用上你的控制台了</h2>
<p>我不知道你有没有在现实中有幸看过别人用控制台表演奇迹淫巧，他们可能会说些这样的话，“对,只要 cd 到那个文件夹,然后跑 build.ps1,问题应该就解决了” 。</p>
<p>其实这些话别人压根听不懂。甚至有些开发人员也不懂，毕竟，如果你不 cd 到那个目录，你跑什么东西呢？</p>
<p>在工作中要善用这些命令。当然，Git 是有 GUI 版本的，但是有必要用吗？还是打开 pwershell 或者 cmd，输入 git 命令，记得提交代码要加说明信息，比如“修复了一个 bug”。</p>
<p>在 VSCode 中集成了一个终端，听起来好像没什么用，但是用了之后，真香！我用的是德文键盘，用 <strong>Ctrl-Ö</strong>  就能打开终端，而且很容易记忆，因为德文里终端的单词就是 Ökonsole。可以说十分友好了。<strong>Ctrl-P</strong> 可以打开命令盘（pan），在里面找到所有通用的 VSCode 功能。</p>
<p><strong>Tab</strong> 键在终端中可以用作自动补全。多次按下 <strong>tab</strong> 键在提示出的可选项中切换，<strong>Shift-tab</strong> 可以回到上一个可选项。</p>
<p>使用方向上键会自动输入上一个命令，你可以修复一下语法错误。如果你不小心已经提交到了 master 分支的话，教你一个神奇的命令，git -unfuck -everything，然后一切都变好了，不需要 rebase 和 merge。</p>
<h2 id="少装逼要谦虚好学好问才是真理">少装逼，要谦虚，好学好问，才是真理</h2>
<p>虽然我写了这么多，苦口婆心，但是我知道没有几个人会听得进去。如果你读到了这里，不是因为我的真心打动了你，而是因为你曾经看过某人用键盘装逼，那种感觉，你也想有。<br>
那时候的你想知道如何才能练就键盘装逼大法，现在我告诉你了，给你指了一条明路。等你学成之后，你就不再需要异性了（老婆算个啥？），因为没有人会像键盘那样接受你亲密的抚摸，也没有人会像你的电脑一样懂你需要什么。</p>
<p>恭喜，你跨过了这道坎。即使你还现在还没有秃顶，甚至头发浓密，但你已经走上聪明绝顶的道路。相信我，当别人看到你用键盘现场装逼的时候，他也一定会想跟你学一手的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[译文]给菜鸟看的-Android-Architecture-Components-(安卓架构组件)知识（kotlin）]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/gei-cai-niao-kan-de-android-architecture-components-an-zhuo-jia-gou-zu-jian-zhi-shi-kotlin/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/gei-cai-niao-kan-de-android-architecture-components-an-zhuo-jia-gou-zu-jian-zhi-shi-kotlin/">
        </link>
        <updated>2019-05-28T12:23:51.000Z</updated>
        <content type="html"><![CDATA[<p>本文为译文，原文链接：<br>
<a href="https://medium.com/@elye.project/android-architecture-components-for-dummies-in-kotlin-50-lines-of-code-29b29d3a381">https://medium.com/@elye.project/android-architecture-components-for-dummies-in-kotlin-50-lines-of-code-29b29d3a381</a></p>
<p>以前写 android 程序时，只需要把所有代码写在 Activity 中就可以了，比如：</p>
<pre><code class="language-java">class MainActivity : AppCompatActivity() {
    private var count = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        my_container.setOnClickListener { incrementCount() }
    }

    override fun onResume() {
        super.onResume()
        incrementCount()
    }

    private fun incrementCount() {
        my_text.text = (++count).toString()
    }
}
</code></pre>
<p>仅仅用小于 20 行的代码，你就可以实现一个计数程序，统计每次你点击和前台显示 App 的次数。<br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615724725735.png" alt="房子.png" loading="lazy"><br>
这样的代码虽然简单，但是却难以扩展成一个大型项目，就像上图中的小房子一样，有很多问题：<br>
1、如果你旋转你的设备，<code>count</code> 会被重置为 0<br>
2、这样的代码很难进行单元测试<br>
3、把所有东西都放在一个 class 里面，会让开发者变笨变迟钝。也许你是个菜鸟，但你一定不想变成笨笨的开发者。</p>
<h2 id="代码架构">代码架构</h2>
<p>有许多中方法可以更好地组织你的代码结构。最基本的方法就是把代码拆分成不同的 class ，我们称其为 <strong>关注点分离</strong>。<br>
你可能听说过 MVP 、MVC 、MVVM...如果你很了解这些概念并且运用自如，那么你可以不用看这篇文章了，去喝杯咖啡然后干别的事情吧</p>
<p>如果不是的话，那么请继续读下去...</p>
<p>简单来说，通过把逻辑代码尽可能多地从 Activity 当中移到别的类当中就可以实现关注点分离。你地 Activity 只会去处理和 Android 本身相关地工作，以及 UI 的更新。让别的类来处理重要的逻辑事务。<br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615724796401.png" alt="分离视图和逻辑.png" loading="lazy"><br>
这样的话。任何 LifeCycle 事件都由 Activity 通知 Logic class ，同时对于任何数据的改变，你的 Logic class 都会将其通知到 Activity 。<br>
很简单吧？虽然听起来很简单，但是每个人具体实现的方式都不同。这就是 MVP 、MVC  、MVVM （我甚至听过 MVVMI）的由来。即使是同一种架构，代码写法也会有许多不同。</p>
<h2 id="谷歌看不下去了">谷歌看不下去了</h2>
<p>开发者使用各种架构、各种方法来分离视图和逻辑层，那么哪种是最好的呢？人们忍不住问谷歌。于是在 2017 的 Google IO 大会上，Google 决定提出他自己的解决方案。这就是我们说的 Android Architecture Components (安卓架构组件)。<br>
如下图所示，看起来和前文的图几乎一样，但是有了更清楚的命名。<br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615724887879.png" alt="" loading="lazy"></p>
<h2 id="什么是-mvvmmodel-view-viewmodel">什么是 MVVM（Model View ViewModel)？</h2>
<p>当你看见 ViewModel 这个词的时候，你可能会很容易的就联想到 MVVM 。但是 MVVM 到底是什么？<br>
简单来说，它是基于 <a href="%5Bhttps://en.wikipedia.org/wiki/Observer_pattern%5D(https://en.wikipedia.org/wiki/Observer_pattern)">观察者</a> 模式实现的架构。<br>
在这种模式中，信息的提供者并不知道谁需要他去提供这些信息。但是对这些信息感兴趣的人会对其进行订阅，一旦信息发布，就可以获取到需要的信息。<br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615724954175.png" alt="就像你订阅一个 B 站 UP 主一样，他们一更新，你就能得到通知" loading="lazy"><br>
这样，你大概就能猜到：<br>
1、ViewModel 通过 Activity 的 LifeCycle 对象订阅 Activity ，以便在 LifeCycleEvents 发生时得到通知<br>
2、Activity 通过ViewModel 的 LiveData 对象订阅 ViewModel ，以便在数据更新时得到通知</p>
<h2 id="使用安卓架构组件">使用安卓架构组件</h2>
<p>好了，理论已经谈得足够多了，现在让我们来看看怎么在代码中使用他们。</p>
<h3 id="添加依赖">添加依赖</h3>
<p>在我给出的这个例子中，在 app 的 build.gradle 中添加下面的依赖就足够了。还有很多其他的库，但是现在不需要它们。</p>
<pre><code>implementation &quot;android.arch.lifecycle:extensions:1.1.0&quot;
</code></pre>
<h3 id="viewmodel-类和它的-livedata">ViewModel 类和它的 LiveData</h3>
<p>依赖添加完之后，就创建一个 ViewModel 类</p>
<pre><code class="language-java">class MyViewModel(private var count: Int = 0) : ViewModel() {
        val changeNotifier = MutableLiveData&lt;Int&gt;()
        fun increment() { changeNotifier.value = ++ count }
}
</code></pre>
<p>为了能够更简单地在 Activity 中使用它，最好是继承自 <code>ViewModel</code> 。现在这个类中包含了<code>count</code>变量，在我们点击或者 activity 出现在前台时，我们会用它进行 UI 的更新。除此之外，还包含了 名为 <code>changeNotifier</code>的 MutableLiveData 。只要<code>count</code>发生改变，我仅需要相应地更新 changeNotifier.value ，不论是谁订阅了它，都能获取更新的数据。</p>
<h3 id="在-mainactivity-中使用-viewmodel">在 MainActivity 中使用 ViewModel</h3>
<p>完成了上述工作，现在我们需要把这个 ViewModel 类提供给我们的 MainActivity。</p>
<pre><code class="language-java">class MainActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by lazy {
        ViewModelProviders.of(this).get(MyViewModel::class.java)
    }

    private val changeObserver =
            Observer&lt;Int&gt; { 
                 value -&gt; value?.let { incrementCount(value) } 
            }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        viewModel.changeNotifier.observe(this, changeObserver)
        my_container.setOnClickListener { viewModel.increment() }
    }

    private fun incrementCount(value: Int) {
        my_text.text = (value).toString()
    }
}
</code></pre>
<p>我们使用了<code>lazy</code>关键词来创建<code>viewModel</code>，这是谷歌推荐的方法</p>
<pre><code class="language-java">private val viewModel: MyViewModel by lazy {
        ViewModelProviders.of(this).get(MyViewModel::class.java)
    }
</code></pre>
<p>之后， 我们的代码写出了获取消息的行为以及获得消息后干什么。在 Kotlin 中，我们使用 lambda 表达式，这样会让代码看起来更干净。</p>
<pre><code class="language-java">private val changeObserver =
            Observer&lt;Int&gt; { 
                 value -&gt; value?.let { incrementCount(value) } 
            }
</code></pre>
<p>之后我们必须使用下面的代码将 <code>changeObserver</code>注册到<code>viewModel</code>。</p>
<pre><code class="language-java">viewModel.changeNotifier.observe(this, changeObserver)
</code></pre>
<p>最后， 我们需要一个方法从 UI 去触发数据的变化。在这个例子中是通过点击事件。</p>
<pre><code class="language-java">my_container.setOnClickListener { viewModel.increment() }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://ultimateHandsomeBoy666.github.io//post-images/1615725024720.png" alt="事件触发流程" loading="lazy"></figure>
<p>从 MainActivity 到 ViewModel  再回到 MainActivity 就像是一趟往返的路途。我们并没有把所有的事情都放到 MainActivity 中来做，这样虽然看起来复杂了一点，但是我们却搭建了一个好的 App 架构。这样就能把逻辑代码全部转移到 ViewModel 中而不是 MainActivity 。</p>
<h3 id="让-viewmodel-感知到-activity-的生命周期变化">让 ViewModel 感知到 Activity 的生命周期变化</h3>
<p>为了让 ViewModel 感知到 Activity 的生命周期变化，我们需要让它实现 <code>LifeCycleObserver</code>接口。</p>
<pre><code class="language-java">class MyViewModel(private var count: Int = 0) : ViewModel(),   
    LifecycleObserver {
    val changeNotifier = MutableLiveData&lt;Int&gt;()
    fun increment() { changeNotifier.value = ++count }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) 
    fun onResume() { increment() }
}
</code></pre>
<p>你的 <code>viewModel</code>依赖于哪一个生命周期，就添加一个 @OnLifecycleEvent 注解。<br>
在这个例子中，我们只对 ON_RESUME 感兴趣。<br>
做完这步后，我们需要让<code>viewModel</code>订阅 <code>MainActivity</code>的<code>Lifecycle</code>事件。在最新版本的 <code>AppCompatActivity</code> 类中，<code>LifeCycle</code>已经添加进来了。所以我们可以轻松地在<code>onCreate</code>函数中实现如下代码：</p>
<pre><code class="language-java">override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        viewModel.changeNotifier.observe(this, changeObserver)
        lifecycle.addObserver(viewModel)             
        my_container.setOnClickListener { viewModel.increment() }
    }
</code></pre>
<p><img src="https://ultimateHandsomeBoy666.github.io//post-images/1615725047082.png" alt="生命周期感知" loading="lazy"><br>
现在<code>viewModel</code>就不需要让<code>MainActivity</code>在每个生命周期事件发生时主动地调用<code>viewModel</code>的方法。只需要合适的<code>@OnLifeCycleEvent</code>注解，<code>viewModel</code>就会被通知到并且执行相应的逻辑。</p>
<h3 id="妈妈再也不用担心我旋转设备了">妈妈再也不用担心我旋转设备了</h3>
<p>现在我们可以轻松地扩展我们地 App ，在<code>viewModel</code>中实现更复杂地逻辑。并且，相比于<code>Activity</code>,我们在可以在<code>viewModel</code>中更好地进行单元测试。<br>
除此之外，最重要地一点时，当我们旋转设备时，<code>count</code>不会再被重置为 0 。它的值被保存下来了，因为 Android 内部实现了在 ViewModel 中保存数据的机制，不需要你去显式地保存它。</p>
<h3 id="但也不要高兴地太早">但也不要高兴地太早</h3>
<p>虽然 ViewModel 可以很好地保存数据，但是这并不意味着<code>onSaveInstanceState</code>就没有用武之地了。如果 Activity 被进程被系统杀死，那么<code>count</code>地值就不会被保存。<br>
为了处理这个问题，我添加了处理<code>savedInstanceState</code>的逻辑代码。</p>
<pre><code class="language-java">class MainActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by lazy {
        ViewModelProviders.of(this).get(MyViewModel::class.java)
    }

    private val changeObserver = Observer&lt;Int&gt; { 
                  value -&gt; value?.let { incrementCount(value) } 
            }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        viewModel.restoreState(savedInstanceState)
        viewModel.changeNotifier.observe(this, changeObserver)
        lifecycle.addObserver(viewModel)
        my_container.setOnClickListener { viewModel.increment() }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        viewModel.saveState(outState)
    }

    private fun incrementCount(value: Int) {
        my_text.text = (value).toString()
    }
}

class MyViewModel(private var count: Int = 0) : ViewModel(), 
    LifecycleObserver {
    companion object { const val COUNT_KEY = &quot;CountKey&quot; }

    val changeNotifier = MutableLiveData&lt;Int&gt;()

    fun increment() { changeNotifier.value = ++count }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) 
    fun onResume() { increment() }

    fun saveState(outState: Bundle) {
        outState.putInt(COUNT_KEY, count)
    }

    fun restoreState(inState: Bundle?) {
        inState?.let { count = inState.getInt(COUNT_KEY) }
    }
}
</code></pre>
<p>这样，不论是旋转设备还是进程被杀死，你的<code>count</code>值都可以被保留下来。</p>
<p>源码可以从以下链接获得：<br>
https://github.com/elye/demo_android_architecture_components?source=post_page-----29b29d3a381----------------------</p>
<h3 id="关于-viewmodel-再说一点">关于 ViewModel ，再说一点</h3>
<p>可能上面最终的代码看起来比一开始直接在 Activity 中处理所有事情的代码要长很多。但是，如同画房屋设计图一样，想要实现更多细节，就必须有合理的组织架构，即把逻辑代码从 Activity 当中抽离出来。<br>
我的观点是，如果你已经有熟悉的架构，并且运用自如，那么你就可以不用安卓架构组件， Android Architecture Componens 。除非它能为代码提供更好的表现，比如在杀死和恢复应用进程时保留变量值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 实现图表实时更新]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/android-shi-xian-tu-biao-shi-shi-geng-xin/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/android-shi-xian-tu-biao-shi-shi-geng-xin/">
        </link>
        <updated>2019-05-22T11:05:57.000Z</updated>
        <content type="html"><![CDATA[<p>项目里需要App端不断地从服务器获取数据，实时生成图表。图表控件使用的是<a href="https://github.com/PhilJay/MPAndroidChart">MPAndroidChart</a>。自己写了些实时更新折线图的demo，数据是线程随机生成的，不是后台数据。</p>
<h3 id="1-message配合handler实现">1、Message配合Handler实现</h3>
<p>效果如下<br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615723745197.gif" alt="Message配合Handler实现.gif" loading="lazy"><br>
在MainActivity中创建一个产生随机数据的线程，每产生一个数据发送一个Message，Handler收到Message之后更新折线图。</p>
<p>MainActivity代码如下：</p>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {
    private static final int TAG = 1;//Message的what标识
    private TextView mTextView;
    private Button mStartButton;

    private LineChart mLineChart;
    private Data[] mDatas;
    private List&lt;Entry&gt; mEntries = new ArrayList&lt;&gt;();

    private Thread mThread;
    private Handler mHandler;
    private Random mRandom;

    private StringBuilder mStringBuilder;
    private int mEndIndex;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mTextView = findViewById(R.id.test_txt);
        mStartButton = findViewById(R.id.start_button);
        mLineChart = findViewById(R.id.line_chart);

        mRandom = new Random();
        mStringBuilder = new StringBuilder(&quot;现在Y轴数字是0哦&quot;);
        mEndIndex = 1;

        //先创建5个Data数据
        mDatas = new Data[]{new Data(1,5),new Data(2,8),
               new Data(3,10),new Data(4,13),new Data(5,16)};
        for (Data data :mDatas){
            mEntries.add(new Entry(data.getValueX(),data.getValueY()));
        }
        LineDataSet dataSet = new LineDataSet(mEntries,&quot;number&quot;);
        LineData lineData = new LineData(dataSet);
        mLineChart.setData(lineData);
        mLineChart.invalidate();


        mHandler = new Handler(){
            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                if (msg.what==TAG){
                    updateTxt(msg);
                    updateChart(msg);
                }
            }
        };

        mThread = new Thread(new Runnable() {
            @Override
            public void run() {
                int corrX = 6;//已经有了五个数据，下一个数据的x坐标从6开始
                while (true){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    int corrY = mRandom.nextInt(20) + 5;
                    Message message = Message.obtain();
                    message.arg1 = corrY;
                    message.arg2 = corrX;
                    message.what = TAG;
                    mHandler.sendMessage(message);
                    corrX += 1;
                }
            }
        });

        mStartButton.setOnClickListener((View v) -&gt; mThread.start());

    }

    //更新SpannableString类型的文本需要用该函数判断更新数字的位数
    private int endIndex(int i){
        int index = 0;
        while (i!=0){
            i = i/10;
            index += 1;
        }
        return index;
    }

    //更新显示当前值的TextView
    private void updateTxt(Message msg){
        mStringBuilder.replace(7,7 + mEndIndex, msg.arg1 + &quot;&quot;);//将原来的数字替换

        SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder(mStringBuilder);
        ForegroundColorSpan foregroundColorSpan = new ForegroundColorSpan(Color.BLUE);
        RelativeSizeSpan relativeSizeSpan = new RelativeSizeSpan(1.5f);

        mEndIndex = endIndex(msg.arg1);//新的y值的位数

        spannableStringBuilder.setSpan(foregroundColorSpan,7,7 + mEndIndex, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
        spannableStringBuilder.setSpan(relativeSizeSpan,7,7 + mEndIndex, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
        mTextView.setText(spannableStringBuilder);

    }

    //刷新折线图
    private void updateChart(Message msg){
        mEntries.add(new Entry(msg.arg2,msg.arg1));
        LineDataSet dataSet = new LineDataSet(mEntries,&quot;number&quot;);
        LineData lineData = new LineData(dataSet);
        mLineChart.setData(lineData);
        mLineChart.invalidate();
    }

}
</code></pre>
<p>Data类如下</p>
<pre><code class="language-Java">public class Data {
    private int valueX;
    private int valueY;

    public Data(int x,int y){
        this.valueX = x;
        this.valueY = y;
    }

    public int getValueX() {
        return valueX;
    }

    public void setValueX(int valueX) {
        this.valueX = valueX;
    }

    public int getValueY() {
        return valueY;
    }

    public void setValueY(int valueY) {
        this.valueY = valueY;
    }
}
</code></pre>
<h3 id="2-rxjava实现">2、RxJava实现</h3>
<p>Rxjava在处理复杂的多线程事件逻辑时比Handler/Async等要简单易用可靠。用来写这个demo算是大炮打蚊子，纯当练手了。</p>
<p>MainActivity</p>
<pre><code class="language-Java">public class MainActivity extends AppCompatActivity {
    private static final String TAG = &quot;MainActivity&quot;;
    private LineChart mLineChart;
    private TextView mTextView;
    private Button mStartButton;
    private List&lt;Entry&gt; mEntryList = new ArrayList&lt;&gt;();

    private Random mRandom;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mLineChart = findViewById(R.id.line_chart);
        mStartButton = findViewById(R.id.start_button);
        mTextView = findViewById(R.id.value_txt);

        mStartButton.setOnClickListener((View v) -&gt; intervalObservable());
    }

    private void intervalObservable() {
        mRandom = new Random();
        Observable.interval(1000, 1000, TimeUnit.MILLISECONDS)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;Long&gt;() {
                    @Override
                    public void accept(Long aLong) throws Exception {
                        Log.e(&quot;intervalObservable&quot;, Thread.currentThread().getName());
                        Long x = aLong;
                        int y = mRandom.nextInt(10);
                        Data data = new Data(x, y);
                        x++;

                        mEntryList.add(new Entry(data.getX(), data.getY()));
                        LineDataSet dataSet = new LineDataSet(mEntryList, &quot;label&quot;);
                        LineData lineData = new LineData(dataSet);
                        mLineChart.setData(lineData);
                        mLineChart.invalidate();
                        mTextView.setText(&quot;当前y值为&quot; + y);
                    }
                });
    }
}
</code></pre>
<p>写的时候发现如果直接用Observable.create()生成数据的话，速度太快，MPAndroidChart刷新不过来，一片空白。所以改用Observable.interval()，每个1秒生成一个，但是这个函数只能返回一个Observable<Long>的对象，每次发射的都是Long类型的数据，所以把Data类型中的x值改成了Long类型。<br>
还要注意的是，Observable.interval()默认订阅Schedulers.computation这个线程，如果有UI更新的话，需要在主线程中进行观察，即调用observeOn(AndroidSchedulers.mainThread())。<br>
<strong>但是我发现一个很神奇的事，MPAndroidChart可以在非UI线程中进行刷新</strong>。</p>
<p>难道只能用Observal.interval()吗?其实不是的，我发现只要使被观察者线程休眠一小段时间，就能让折线图刷新出来，代码如下</p>
<pre><code class="language-java">Observable.create(new ObservableOnSubscribe&lt;Data&gt;() {
            @Override
            public void subscribe(@NonNull ObservableEmitter&lt;Data&gt; e) throws Exception {
                Long x = 0l;
                Random random = new Random();
                while(x &lt; 1000) {
                    int y = random.nextInt(10);
                    Data data = new Data(x, y);
                    e.onNext(data);
                    x++;
                    Thread.sleep(1000);//休眠1秒
                }
                Log.e(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());
            }
        }).subscribeOn(Schedulers.newThread())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(data -&gt; {
                Log.i(&quot;onNext(Data data)&quot;, data.toString());
                Log.e(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());
                mEntryList.add(new Entry(data.getX(), data.getY()));
                LineDataSet dataSet = new LineDataSet(mEntryList, &quot;label&quot;);
                LineData lineData = new LineData(dataSet);
                mLineChart.setData(lineData);
                mLineChart.invalidate();
                mTextView.setText(&quot;当前值为&quot; + data.getY());
            });
</code></pre>
<p>其实在订阅者线程中休眠也可以正常接收到数据，但订阅者线程一般是UI线程，休眠的话，UI就不会更新了。<br>
另外，被观察者的线程没有休眠的话，即使被观察者数据发送的很快，订阅者在onNext()即使进行了线程休眠，数据也能全部接收到，不会出现事件丢失的情况，这一点让我比较疑惑。<br>
如果被观察者的线程调用了Thread.sleep(1)，而观察者在onNext()中调用了Thread.sleep(1000)，那么会出现上下游事件处理速率不匹配，事件丢失，OOM等情况。<br>
这个时候就要用支持背压的Flowable了。<br>
其实用Flowable同样可以实现折线图更新，代码如下：</p>
<pre><code class="language-java">Flowable.create(new FlowableOnSubscribe&lt;Data&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Data&gt; e) throws Exception{
                Long x = 0l;
                Random random = new Random();
                while(x &lt; 1000) {
                    int y = random.nextInt(10);
                    Data data = new Data(x, y);
                    e.onNext(data);
                    x++;
                    Thread.sleep(1000);
                }
                Log.e(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());
            }
        }, BackpressureStrategy.BUFFER).subscribeOn(Schedulers.newThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Subscriber&lt;Data&gt;() {
                    Subscription mSubscription;
                    @Override
                    public void onSubscribe(Subscription s) {
                        mSubscription = s;
                        s.request(1);
                    }

                    @Override
                    public void onNext(Data data) {
                        Log.i(&quot;onNext(Data data)&quot;, data.toString());
                        Log.e(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());
                        mEntryList.add(new Entry(data.getX(), data.getY()));
                        LineDataSet dataSet = new LineDataSet(mEntryList, &quot;label&quot;);
                        LineData lineData = new LineData(dataSet);
                        mLineChart.setData(lineData);
                        mLineChart.invalidate();
                        mTextView.setText(&quot;当前值为&quot; + data.getY());

                        mSubscription.request(1);
                    }

                    @Override
                    public void onError(Throwable t) {

                    }

                    @Override
                    public void onComplete() {

                    }
                });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 退出登录，清空任务栈]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/android-tui-chu-deng-lu-qing-kong-ren-wu-zhan/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/android-tui-chu-deng-lu-qing-kong-ren-wu-zhan/">
        </link>
        <updated>2019-05-15T11:47:24.000Z</updated>
        <content type="html"><![CDATA[<p>在项目中要实现用户退出登录的功能，当用户点击退出登录按钮后，跳转到登录页面的 Activity ，直接用 startActivity() 跳转，点击返回键后仍会回到退出前的 Activity 。</p>
<p>如果使用下面这句代码给 intent 设置 Flag</p>
<pre><code class="language-java">intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
</code></pre>
<p>在第一次登录时有效，因为用户第一次登录时会在登录页面输入账号密码进行登录，然后跳转到主页面。这样在退出登录时，会回到之前经过的登录 Activity ，任务栈会将登录页面<br>
Activity 之上的 Activity 全部清空，按返回键不会回到主页面。<br>
但是在用户已经登录过之后，由于账号密码已经保存，不需要再次输入进行登录，不会经过登录 Activity ， 这样在退出登录后按返回键仍会返回到主页面。</p>
<p>使用 FLAG_ACTIVITY_CLEAR_TASK ， FLAG_ACTIVITY_NEW_TASK 即可解决。代码如下：</p>
<pre><code class="language-java">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
</code></pre>
<p><strong>注意是 addFlags() 不是 setFlags()</strong><br>
谷歌官方文档提到， Intent.FLAG_ACTIVITY_CLEAR_TASK 要起作用，必须和 Intent.FLAG_ACTIVITY_NEW_TASK 配合使用。<br>
这两个 Flag 可以将原有任务栈清空,并将 intent 的目标 Activity 作为任务栈的根 Activity 。任务栈的 Id 没有变，如下所示，也就是说，并没有开辟新的任务栈。</p>
<pre><code>I/得到TaskId: 19959
</code></pre>
<pre><code>I/得到TaskId: 19959
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HashMap 和 HashTable 的区别]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/hashmap-he-hashtable-de-qu-bie/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/hashmap-he-hashtable-de-qu-bie/">
        </link>
        <updated>2019-04-29T10:57:03.000Z</updated>
        <content type="html"><![CDATA[<p>1、HashTable和HashMap均实现了Map、Cloneable、Serializable接口，但是HashMap继承至实现了Map接口的AbstractMap类，而HashTable除了实现Map接口，还继承了已被废弃的Dicationary类，如下图所示：<br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615719886086.png" alt="HashMap 的继承关系" loading="lazy"><br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615719976617.png" alt="HashTable 的继承关系" loading="lazy"><br>
2、HashMap的key和value值可以为null，而HashTable遇到null会抛出NullPointerException。HashMap遇到null的key会将其赋值为0。<br>
3、HashTable是线程安全的，而HashMap不是。如果你需要线程安全的HashMap，使用ConcurrentHashMap。或者用如下代码让HashMap同步：</p>
<pre><code class="language-java">Map map = Collections.synchronizeMap(hashMap);
</code></pre>
<p>如果不需要线程安全，使用HashMap，HashTable已经不再推荐使用。<br>
4、HashMap的迭代器(Iterator)是fail-fast(快速失败)迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p>
<p>感谢参考文章：<br>
1、<a href="http://www.importnew.com/7010.html">HashMap和Hashtable的区别</a><br>
2、 <a href="https://www.cnblogs.com/xinzhao/p/5644175.html">HashMap和HashTable到底哪不同？</a></p>
]]></content>
    </entry>
</feed>