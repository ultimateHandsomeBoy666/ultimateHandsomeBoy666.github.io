<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ultimateHandsomeBoy666.github.io/</id>
    <title>牛蛙的博客</title>
    <updated>2021-03-14T11:58:09.162Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ultimateHandsomeBoy666.github.io/"/>
    <link rel="self" href="https://ultimateHandsomeBoy666.github.io/atom.xml"/>
    <subtitle>Hello!</subtitle>
    <logo>https://ultimateHandsomeBoy666.github.io/images/avatar.png</logo>
    <icon>https://ultimateHandsomeBoy666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 牛蛙的博客</rights>
    <entry>
        <title type="html"><![CDATA[Android 退出登录，清空任务栈]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/android-tui-chu-deng-lu-qing-kong-ren-wu-zhan/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/android-tui-chu-deng-lu-qing-kong-ren-wu-zhan/">
        </link>
        <updated>2019-05-15T11:47:24.000Z</updated>
        <content type="html"><![CDATA[<p>在项目中要实现用户退出登录的功能，当用户点击退出登录按钮后，跳转到登录页面的 Activity ，直接用 startActivity() 跳转，点击返回键后仍会回到退出前的 Activity 。</p>
<p>如果使用下面这句代码给 intent 设置 Flag</p>
<pre><code class="language-Java">intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
</code></pre>
<p>在第一次登录时有效，因为用户第一次登录时会在登录页面输入账号密码进行登录，然后跳转到主页面。这样在退出登录时，会回到之前经过的登录 Activity ，任务栈会将登录页面<br>
Activity 之上的 Activity 全部清空，按返回键不会回到主页面。<br>
但是在用户已经登录过之后，由于账号密码已经保存，不需要再次输入进行登录，不会经过登录 Activity ， 这样在退出登录后按返回键仍会返回到主页面。</p>
<p>使用 FLAG_ACTIVITY_CLEAR_TASK ， FLAG_ACTIVITY_NEW_TASK 即可解决。代码如下：</p>
<pre><code class="language-Java">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
</code></pre>
<p>######注意是 addFlags() 不是 setFlags()<br>
谷歌官方文档提到， Intent.FLAG_ACTIVITY_CLEAR_TASK 要起作用，必须和 Intent.FLAG_ACTIVITY_NEW_TASK 配合使用。<br>
这两个 Flag 可以将原有任务栈清空,并将 intent 的目标 Activity 作为任务栈的根 Activity 。任务栈的 Id 没有变，如下所示，也就是说，并没有开辟新的任务栈。</p>
<pre><code>I/得到TaskId: 19959
</code></pre>
<pre><code>I/得到TaskId: 19959
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HashMap 和 HashTable 的区别]]></title>
        <id>https://ultimateHandsomeBoy666.github.io/post/hashmap-he-hashtable-de-qu-bie/</id>
        <link href="https://ultimateHandsomeBoy666.github.io/post/hashmap-he-hashtable-de-qu-bie/">
        </link>
        <updated>2019-04-29T10:57:03.000Z</updated>
        <content type="html"><![CDATA[<p>1、HashTable和HashMap均实现了Map、Cloneable、Serializable接口，但是HashMap继承至实现了Map接口的AbstractMap类，而HashTable除了实现Map接口，还继承了已被废弃的Dicationary类，如下图所示：<br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615719886086.png" alt="HashMap 的继承关系" loading="lazy"><br>
<img src="https://ultimateHandsomeBoy666.github.io//post-images/1615719976617.png" alt="HashTable 的继承关系" loading="lazy"><br>
2、HashMap的key和value值可以为null，而HashTable遇到null会抛出NullPointerException。HashMap遇到null的key会将其赋值为0。<br>
3、HashTable是线程安全的，而HashMap不是。如果你需要线程安全的HashMap，使用ConcurrentHashMap。或者用如下代码让HashMap同步：</p>
<pre><code>Map map = Collections.synchronizeMap(hashMap);
</code></pre>
<p>如果不需要线程安全，使用HashMap，HashTable已经不再推荐使用。<br>
4、HashMap的迭代器(Iterator)是fail-fast(快速失败)迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p>
<p>感谢参考文章：<br>
1、<a href="http://www.importnew.com/7010.html">HashMap和Hashtable的区别</a><br>
2、 <a href="https://www.cnblogs.com/xinzhao/p/5644175.html">HashMap和HashTable到底哪不同？</a></p>
]]></content>
    </entry>
</feed>